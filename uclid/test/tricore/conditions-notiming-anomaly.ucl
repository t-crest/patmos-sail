module conditions {
    var ops_i, ops_j: common.instr_pair_t;
    var latencies_i, latencies_j: common.dual_latencies_t;
    var stages_i: common.dual_stage_t;
    var bus: common.bus_access_t;
    var full_SB_i: boolean;
    var mem_dep: boolean;

    instance cond : test(cond_ops_i: (ops_i), cond_ops_j: (ops_j),
                         cond_latencies_i: (latencies_i),
                         cond_latencies_j: (latencies_j),
                         cond_stages_i: (stages_i),
                         cond_bus: (bus),
                         cond_full_SB_i: (full_SB_i),
                         cond_mem_dep: (mem_dep));
    
    
    procedure set_init_SB()
        modifies ops_i, ops_j;
    {
        assume(ops_i.LS_instr == nop || ops_i.LS_instr == load_op || ops_i.LS_instr == store_op || ops_i.LS_instr == other_op);
        assume(ops_j.LS_instr == nop || ops_j.LS_instr == load_op ||  ops_j.LS_instr == store_op ||ops_j.LS_instr == other_op);
        
        // SB unused if not a store
        assume(ops_i.LS_instr != store_op ==> full_SB_i == false);
        // A load following a store may be dependent: load is current (j) and store is previous (i)
        assume((ops_i.LS_instr != store_op || ops_j.LS_instr != load_op) ==> mem_dep == false);
        
        // Write-allocate cache: no main mem access
        assume(mem_dep ==> !bus.dbus_j); // simplification as scratchpads…
        
        // Assume variable latencies for SB
        assume((!bus.dbus_i && ops_i.LS_instr == store_op) ==> (latencies_i.LS_pipe.ST == 1 || latencies_i.LS_pipe.ST == 2));
        assume((!bus.dbus_j && ops_j.LS_instr == store_op) ==> (latencies_j.LS_pipe.ST == 1 || latencies_j.LS_pipe.ST == 2));
        assume((bus.dbus_i && ops_i.LS_instr == store_op && stages_i.LS_pipe != ST) ==> latencies_i.LS_pipe.ST == 15); // unchecked latencies…
        assume((bus.dbus_i && ops_i.LS_instr == store_op && stages_i.LS_pipe == ST) ==> (1 < latencies_i.LS_pipe.ST && latencies_i.LS_pipe.ST <= 15));
        assume((bus.dbus_j && ops_j.LS_instr == store_op) ==> latencies_j.LS_pipe.ST == 15);
    }
    
    procedure set_init_general_reduction()
        modifies latencies_i, latencies_j;
    {
        // Reduce state space by disabling variability: unused latencies since stages overtaken
        assume((stages_i.I_pipe == WB || stages_i.I_pipe == EX2) ==> (latencies_i.I_pipe.IF == 1 && latencies_i.I_pipe.ID == 1 && latencies_i.I_pipe.EX == 1));
        assume(stages_i.I_pipe == EX ==> (latencies_i.I_pipe.IF == 1 && latencies_i.I_pipe.ID == 1));
        assume(stages_i.I_pipe == ID ==> (latencies_i.I_pipe.IF == 1));
        assume((stages_i.LS_pipe == WB || stages_i.LS_pipe == EX2) ==> (latencies_i.LS_pipe.IF == 1 && latencies_i.LS_pipe.ID == 1 && latencies_i.LS_pipe.EX == 1 && latencies_i.LS_pipe.EX2 == 1));
        assume(stages_i.LS_pipe == EX ==> (latencies_i.LS_pipe.IF == 1 && latencies_i.LS_pipe.ID == 1));
        assume(stages_i.LS_pipe == ID ==> (latencies_i.LS_pipe.IF == 1));
        
        // For previous instructions (i)
        // If IF stage not reached yet, then this will be total latencies for memory access (extreme values, e.g. cache hit/miss)
        assume((bus.pbus_i.I_pipe && stages_i.I_pipe != IF) ==> (latencies_i.I_pipe.IF == 4 || latencies_i.I_pipe.IF == 5 || latencies_i.I_pipe.IF == 11));
        // If initially within IF stage, partial latencies too (full range)
        assume((bus.pbus_i.I_pipe && stages_i.I_pipe == IF) ==> (1 < latencies_i.I_pipe.IF && latencies_i.I_pipe.IF <= 11));
                
        // Current instructions (j) start both at pre: same as i
        assume(bus.pbus_j.I_pipe ==> (latencies_j.I_pipe.IF == 4 || latencies_j.I_pipe.IF == 5 || latencies_j.I_pipe.IF == 11));
    }
    
    procedure set_init_specific_reduction()
        modifies latencies_i, latencies_j, stages_i;
    {
        // Both pipelines reach IF at the same time
        // Simplification: same component/cache line
        assume(latencies_i.LS_pipe.IF == latencies_i.I_pipe.IF);
        assume(latencies_j.LS_pipe.IF == latencies_j.I_pipe.IF);
        assume(bus.pbus_i.I_pipe == bus.pbus_i.LS_pipe);
        assume(bus.pbus_j.I_pipe == bus.pbus_j.LS_pipe);
    }
    
    procedure set_init_symmetry_reduction()
        modifies ops_i, ops_j;
    {
        assume(ops_i.LS_instr != nop || ops_i.I_instr != nop || ops_j.LS_instr != nop || ops_j.I_instr != nop);
        assume(ops_i.LS_instr != other_op || ops_i.I_instr != other_op || ops_j.LS_instr != other_op || ops_j.I_instr != other_op);
    }
    
    
    init {
        if (param.store_buff) {
            call set_init_SB();
            /*assume(ops_i.LS_instr == store_op);
            assume(ops_j.LS_instr == load_op);
            assume(ops_i.I_instr == other_op);
            assume(ops_j.I_instr == other_op);*/
        }
        else {
            // No variable latency for SB, no need for specific store class
            assume(ops_i.LS_instr == nop || ops_i.LS_instr == load_op || ops_i.LS_instr == other_op);
            assume(ops_j.LS_instr == nop || ops_j.LS_instr == load_op || ops_j.LS_instr == other_op);
            assume(full_SB_i == false && mem_dep == false);
        }
        
        call set_init_general_reduction();
        
        if (param.additional_reduction) {
            call set_init_symmetry_reduction();
        }
        
        if (param.specific_reduction) {
            call set_init_specific_reduction();
        }
        else {
            // Same as I for LS since no equality assumptions (nor any assumptions elsewhere)
            assume((bus.pbus_i.LS_pipe && stages_i.LS_pipe != IF) ==> (latencies_i.LS_pipe.IF == 4 || latencies_i.LS_pipe.IF == 5 || latencies_i.LS_pipe.IF == 11));
            assume((bus.pbus_i.LS_pipe && stages_i.LS_pipe == IF) ==> (1 < latencies_i.LS_pipe.IF && latencies_i.LS_pipe.IF <= 11));
            assume(bus.pbus_j.LS_pipe ==> (latencies_j.LS_pipe.IF == 4 || latencies_j.LS_pipe.IF == 5 || latencies_j.LS_pipe.IF == 11));
        }
        
        // Always assume all types of opcodes for I pipeline
        assume(ops_i.I_instr == nop || ops_i.I_instr == mac_op || ops_i.I_instr == other_op);
        assume(ops_j.I_instr == nop || ops_j.I_instr == mac_op || ops_j.I_instr == other_op);
        
        // Only load/store ops can access bus aside from IF
        assume((ops_i.LS_instr != load_op && ops_i.LS_instr != store_op) ==> !bus.dbus_i);
        assume((ops_j.LS_instr != load_op && ops_j.LS_instr != store_op) ==> !bus.dbus_j);
        
        // Assume latencies for IF without bus access
        assume(!bus.pbus_i.LS_pipe ==> latencies_i.LS_pipe.IF == 1);
        assume(!bus.pbus_i.I_pipe ==> latencies_i.I_pipe.IF == 1);
        assume(!bus.pbus_j.LS_pipe ==> latencies_j.LS_pipe.IF == 1);
        assume(!bus.pbus_j.I_pipe ==> latencies_j.I_pipe.IF == 1);
        
        // Assume latencies for ID in I pipeline
        assume(latencies_i.I_pipe.ID == 1);
        assume(latencies_j.I_pipe.ID == 1);
        
        if (!param.hazards) {
            // No hazard: no variability here
            assume(latencies_i.LS_pipe.ID == 1);
            assume(latencies_j.LS_pipe.ID == 1);
        }
        else {
            // Possible stalling in LS for data/structural hazards
            assume(0 < latencies_i.LS_pipe.ID && latencies_i.LS_pipe.ID <= param.max_stalling);
            assume(0 < latencies_j.LS_pipe.ID && latencies_j.LS_pipe.ID <= param.max_stalling);
        }
        
        // Assume latencies for EX stage apart from load ops with bus access
        assume(ops_i.LS_instr != load_op ==> latencies_i.LS_pipe.EX == 1);
        assume(ops_j.LS_instr != load_op ==> latencies_j.LS_pipe.EX == 1);
        // If it is a load, a cache hit can span 2 cache lines
        assume((!bus.dbus_i && ops_i.LS_instr == load_op) ==> (latencies_i.LS_pipe.EX == 1 || latencies_i.LS_pipe.EX == 2));
        assume((!bus.dbus_j && ops_j.LS_instr == load_op) ==> (latencies_j.LS_pipe.EX == 1 || latencies_j.LS_pipe.EX == 2));
        assume(latencies_i.I_pipe.EX == 1);
        assume(latencies_j.I_pipe.EX == 1);
        
        // Load with bus access
        assume((bus.dbus_i && ops_i.LS_instr == load_op && stages_i.LS_pipe != EX) ==> (latencies_i.LS_pipe.EX == 5 || latencies_i.LS_pipe.EX == 15));
        assume((bus.dbus_i && ops_i.LS_instr == load_op && stages_i.LS_pipe == EX) ==> (1 < latencies_i.LS_pipe.EX && latencies_i.LS_pipe.EX <= 15));
          
        // Current load instructions (j) will pass through EX
        assume((bus.dbus_j && ops_j.LS_instr == load_op) ==> (latencies_j.LS_pipe.EX == 5 || latencies_j.LS_pipe.EX == 15));
        
        // Assume latencies for EX2 stage
        // From this stage, instructions cannot be stalled anymore
        assume(latencies_i.I_pipe.EX2 == 1);
        assume(latencies_i.LS_pipe.EX2 == 1);
        assume(latencies_j.I_pipe.EX2 == 1);
        assume(latencies_j.LS_pipe.EX2 == 1);
          
        // Assume latencies for WB stage
        assume(latencies_i.I_pipe.WB == 1);
        assume(latencies_i.LS_pipe.WB == 1);
        assume(latencies_j.I_pipe.WB == 1);
        assume(latencies_j.LS_pipe.WB == 1);
          
        // Assume latencies for ST stage
        assume(latencies_i.I_pipe.ST == 1);
        assume(ops_i.LS_instr != store_op ==> latencies_i.LS_pipe.ST == 1);
        assume(latencies_j.I_pipe.ST == 1);
        assume(ops_j.LS_instr != store_op ==> latencies_j.LS_pipe.ST == 1);

        // Assume initial stages for previous instr.
        assume(stages_i.I_pipe == pre || stages_i.I_pipe == IF || stages_i.I_pipe == ID || stages_i.I_pipe == EX || stages_i.I_pipe == EX2 || stages_i.I_pipe == WB);
        assume(stages_i.LS_pipe == pre || stages_i.LS_pipe == IF || stages_i.LS_pipe == ID || stages_i.LS_pipe == EX || stages_i.LS_pipe == WB || stages_i.LS_pipe == ST);
        
        // Instruction pairs can split only after IF stage
        assume(stages_i.I_pipe == pre <==> stages_i.LS_pipe == pre);
        assume(stages_i.I_pipe == IF <==> stages_i.LS_pipe == IF);
        
        // This is to allow only specific operations in some stages
        assume(stages_i.I_pipe == EX2 ==> ops_i.I_instr == mac_op);
        assume(stages_i.LS_pipe == ST ==> ops_i.I_instr == store_op);
    }

    next {
        next(cond);
    }
}
