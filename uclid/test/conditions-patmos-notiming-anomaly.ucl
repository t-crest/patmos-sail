module conditions {

  var op_i, op_j: isa.opcode_t;
  var latencies_i, latencies_j: isa.var_latency_t;
//  var src_i, src_j: isa.src_regs_t;
//  var dst_i, dst_j: isa.reg_t;

  instance cond : test(cond_op_i: (op_i), cond_op_j: (op_j),
  	   	           cond_latencies_i: (latencies_i),
		       	   cond_latencies_j: (latencies_j));
//		       	   cond_src_i: (src_i), cond_dst_i: (dst_i),
//		       	   cond_src_j: (src_j), cond_dst_j: (dst_j));  

  init {
    // Assume all type of opcodes
    assume(op_i == nop || op_i == load_op || op_i == store_op ||
    	   op_i == branch_op || op_i == other_op);
    assume(op_j == nop || op_j == load_op || op_j == store_op ||
    	   op_j == branch_op || op_j == other_op);
    // Assume variable latencies for all instructions in IF stage
    assume(latencies_i.fetch == 1);
    assume(latencies_j.fetch == 1);
    // Assume variable latencies for load and store opcodes in MEM stage
    assume((op_i == load_op || op_i == store_op)
    	   ==> 0 < latencies_i.mem && latencies_i.mem <= param.max_latency);
    assume((op_j == load_op || op_j == store_op)
    	   ==> 0 < latencies_j.mem && latencies_j.mem <= param.max_latency);
    // Branch are discarded at the EX stage ... 
    assume(op_i == branch_op ==> latencies_i.mem == 0);
    assume(op_j == branch_op ==> latencies_j.mem == 0);
    // Assume that other operations also take 1 cycle (again see figure 6.4)
    assume(op_i == other_op ==> latencies_i.mem == 1);
    assume(op_j == other_op ==> latencies_j.mem == 1);
  }

  next {
    next(cond);
  }

}
