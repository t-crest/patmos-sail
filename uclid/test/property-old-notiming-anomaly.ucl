// This module only contains properties and assumption to proove the absence of timing anomalies

module param {
  const bmc_depth: integer = 40;

  const max_latency: integer = 10;
}

module main {

  type stage_t = isa.stage_t;

  var op_i, op_j: isa.opcode_t;
  var latencies_i, latencies_j: isa.var_latency_t;
  var src_i, src_j: isa.src_regs_t;
  var dst_i, dst_j: isa.reg_t;

  var step : integer;

  // instance pipeline : sic(current_op: (op_i), previous_op: (op_j),
  // 	   	          current_latencies: (latencies_i),
  // 			  previous_latencies: (latencies_j));

  instance pipeline : inorder(current_op: (op_i), previous_op: (op_j),
  	   	          current_latencies: (latencies_i),
			  previous_latencies: (latencies_j),
			  current_src: (src_i), current_dst: (dst_i),
		       	  previous_src: (src_j), previous_dst: (dst_j));

  init {
    step = 0;

    // Assume all type of opcodes
    assume(op_i == nop || op_i == load_op || op_i == store_op ||
    	   op_i == branch_op || op_i == other_op);
    assume(op_j == nop || op_j == load_op || op_j == store_op ||
    	   op_j == branch_op || op_j == other_op);
    // Assume variable latencies for all instructions in IF stage
    assume(0 < latencies_i.fetch && latencies_i.fetch <= param.max_latency);
    assume(0 < latencies_j.fetch && latencies_j.fetch <= param.max_latency);
    // Assume variable latencies for load and store opcodes in MEM stage
    // TODO: different options could be considered here (intervals or a set of values)
    assume((op_i == load_op || op_i == store_op)
    	   ==> 0 < latencies_i.mem && latencies_i.mem <= param.max_latency);
    assume((op_j == load_op || op_j == store_op)
    	   ==> 0 < latencies_j.mem && latencies_j.mem <= param.max_latency);
    // Assume that branch operations takes 1 cycle in MEM stage (no memory operation)
    // Only updating the PC with the new value in this MEM stage
    // See figure 6.4 of "computer architecture a quantitative approach"
    assume(op_i == branch_op ==> latencies_i.mem == 1);
    assume(op_j == branch_op ==> latencies_j.mem == 1);
    // Assume that other operations also take 1 cycle (again see figure 6.4)
    assume(op_i == other_op ==> latencies_i.mem == 1);
    assume(op_j == other_op ==> latencies_j.mem == 1);
    // Assume latency values in the ST stage
    assume(op_i == store_op ==> 0 < latencies_i.st && latencies_i.st <= param.max_latency);
    assume(op_i != store_op ==> latencies_i.st == 0);
    assume(op_j == store_op ==> 0 < latencies_j.st && latencies_j.st <= param.max_latency);
    assume(op_j != store_op ==> latencies_j.st == 0);        
  }

  next {
    step' = step + 1;  
    next(pipeline);
  }

  // The LTL property for no timing anomaly and the invariant version using delays
  property[LTL] no_timing_anomaly: G((pipeline.previous.instr.stage == MEM &&
  				      (pipeline.previous.instr.opcode == load_op ||
				       pipeline.previous.instr.opcode == store_op))
  				     ==> (pipeline.current.instr.stage != IF));
  invariant no_positive_delays: pipeline.previous.delay == 0;

  // To check that all previous instruction have been retired from the pipeline
  // This is enough, no need to ensure that the current instruction has been retired as well
  property[LTL] bmc_enough: G(step == param.bmc_depth
  			      ==> pipeline.previous.instr.stage == post);

  control {
    vbmc = bmc(param.bmc_depth);
    check;
    print_results;
    vbmc.print_cex(step, pipeline.progress, pipeline.is_inst_ready, pipeline.is_nstage_wbe_free,
    		   pipeline.is_branch_pending, pipeline.is_mem_pending, pipeline.is_store_pending, 
    		   pipeline.current.instr, pipeline.previous.instr);
  }
}
