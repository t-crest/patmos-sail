module main {

  type stage_t = isa.stage_t;
  type opcode_t = isa.opcode_t;

  instance run : conditions();

  next {
    next(run);
  }

  // An invariant for checking the absence of timing anomalies
  invariant no_positive_delays: pipeline.previous.delay == 0;

  // To check that all previous instruction have been retired from the pipeline
  // This is enough, no need to ensure that the current instruction has been retired as well
  property[LTL] bmc_enough: G(step == param.bmc_depth
  			      ==> pipeline.previous.instr.stage == post);

  control {
    vbmc = bmc(param.bmc_depth);
    vunroll = unroll(param.bmc_depth);
    check;
    print_results;
    vbmc.print_cex(rund.cond.step, run.cond.pipeline.progress, run.cond.pipeline.is_inst_ready, run.cond.pipeline.is_nstage_wbe_free,
    		   run.cond.pipeline.is_branch_pending, run.cond.pipeline.is_mem_pending,
		   run.cond.pipeline.is_store_pending, run.cond.pipeline.is_data_dependant,
    		   run.cond.pipeline.current.instr, run.cond.pipeline.previous.instr,
		   run.cond.pipeline.is_mem_blocking, run.cond.pipeline.delays);
    vunroll.print_cex(run.cond.step, run.cond.pipeline.progress, run.cond.pipeline.is_inst_ready, run.cond.pipeline.is_nstage_wbe_free,
    		   run.cond.pipeline.is_branch_pending, run.cond.pipeline.is_mem_pending,
    		   run.cond.pipeline.is_store_pending, run.cond.pipeline.is_data_dependant,
    		   run.cond.pipeline.current.instr, run.cond.pipeline.previous.instr,
		   run.cond.pipeline.is_mem_blocking, run.cond.pipeline.delays);
  }
}
