// Model of SIC (strictly in-order pipeline)
// We remove any latency information in the model which add nothing

// check the pipeline: uclid -m pipeline sic.ucl
// run with some instructions: uclid sic.ucl

// TODO
// - Enhance ready it to monitor delays an instruction
//   is going to suffer from due to previous and subsequent instructions   
// - Specify the invariant property: basically checking that delays due
//   subsequent instructions is always 0
// - Develop a version with several subsequent instructions
// - Develop a version that use prime variable more often than sequential assignment
// - Separate into multiple files to have different version of the pipeline
// - Remove rules to get a classical in-order pipeline and Patmos
// - Design PRET rules

// We were unable to model using an array of record using UCLID
// Arrays of values works well, but we want to update a subset of an element
// of an array -> TLA+ seems better here.

// In an in-order pipeline, instruction i can be blocked by a
// subsequent instruction j (j>i) while j is in fetch stage. In SIC,
// this is avoided as 

module param {
  // The length of the tace
  const trace_length: integer = 8;
}

module isa {
  // Words -- Addresses, Data, etc.
  type word_t = bv32;

  // Pipeline stages
  type stage_t = enum { pre, IF, ID, EX, MEM, ST, WB, post };

  // Opcode 
  type opcode_t = enum { nop, load_op, store_op, branch_op, other_op };

  // Registers. 5 bits to allow 32 registers
  type reg_t = bv5;

  // Source registers
  type src_regs_t = record { src1: reg_t, src2: reg_t };

  // Variable latencies for each instruction
  type var_latency_t = record { fetch: integer, mem: integer, st: integer };

  // Latencies information for each instruction
  type fixed_latency_t = record { id: integer, ex: integer, wb: integer };

  // Delay suffered by each instruction
  type delay_t = record { previous: integer, subsequent: integer };

  // Instruction 
  type inst_t = record { opcode: opcode_t,
			 var_latencies: var_latency_t,
			 src_regs: src_regs_t,
			 dst_reg: reg_t,
			 fixed_latencies: fixed_latency_t,			 
			 stage: stage_t };
}

module instruction {

  // To set the values for the latencies, we need both an input and a var
  // as input are readonly variables ...
  input in_latencies: isa.var_latency_t;
  // The opcode which is set
  input in_opcode: isa.opcode_t;
  // Used in this module as read only values 
  input execute: boolean;

  // The instruction
  var instruction: isa.inst_t;

  // To allow the main module to retrieve values and check delays
  output delays: isa.delay_t;

  init {
    instruction.stage = pre;
    instruction.fixed_latencies.id = 1;
    instruction.fixed_latencies.ex = 1;
    instruction.fixed_latencies.wb = 1;    
    delays.previous = 0;
    delays.subsequent = 0;
  }
  
  procedure latency_IF() modifies instruction; {
    instruction.var_latencies.fetch = instruction.var_latencies.fetch - 1;
  }

  procedure latency_MEM() modifies instruction; {
    instruction.var_latencies.mem = instruction.var_latencies.mem - 1;
  }

  procedure latency_ST() modifies instruction; {
    instruction.var_latencies.st = instruction.var_latencies.st - 1;
  }

  procedure latency_ID() modifies instruction; {
    instruction.fixed_latencies.id = instruction.fixed_latencies.id - 1;
  }

  procedure latency_EX() modifies instruction; {
    instruction.fixed_latencies.ex = instruction.fixed_latencies.ex - 1;
  }

  procedure latency_WB() modifies instruction; {
    instruction.fixed_latencies.wb = instruction.fixed_latencies.wb - 1;
  }

  procedure update_stage() modifies instruction; {
       case
	  (instruction.stage == pre) : { instruction.stage = IF; }
	  (instruction.stage == IF)  : { if (instruction.var_latencies.fetch == 0)
	  		     	       	   { instruction.stage = ID; }
	  	    	     		 else { call latency_IF(); }
				       }
	  (instruction.stage == ID)  : { if (instruction.fixed_latencies.id == 0) {
	  		     	       	   if (instruction.opcode != nop)
					      { instruction.stage = EX; }
	  	    	     		   else { instruction.stage = post; }
					 } else { call latency_ID(); }
				       }
	  (instruction.stage == EX)  : { if (instruction.fixed_latencies.ex == 0) {
	  		     	       	    instruction.stage = MEM;
					 } else { call latency_EX(); }
				       }
	  (instruction.stage == MEM) : { if (instruction.var_latencies.mem == 0) {
	  	    	     	       	   if (instruction.opcode == store_op)
					   { instruction.stage = ST; }
	  		     		   else { instruction.stage = WB; }
			     		 } else { call latency_MEM(); }
	  		   	       }
	  (instruction.stage == ST)  : { if (instruction.var_latencies.st == 0)
	  		     	       	   { instruction.stage = post; }
			     		 else { call latency_ST(); }
			   	       }
	  (instruction.stage == WB ) : { if (instruction.fixed_latencies.wb == 0) {
	  		     	       	    instruction.stage = post;
					  } else  { call latency_WB(); }
				       }
      esac
  }

  next {
    if (execute) {
      call update_stage();
    } 
  }
}

module sic {

  input current_op, subsequent_op: isa.opcode_t;
  input current_latencies, subsequent_latencies: isa.var_latency_t;
  input current_src, subsequent_src: isa.src_regs_t;
  input current_dst, subsequent_dst: isa.reg_t;  

  // Even if this is ugly, this allows to print the value of each
  // variable in the counter-example ...
  var progress: boolean;
  var is_inst_ready : boolean;
  var is_nstage_wbe_free: boolean;  
  
  var is_branch_pending : boolean;
  var is_ninst_ready: boolean;
  var is_mem_pending: boolean;
  var is_store_pending: boolean;
  var is_data_dependant: boolean;

  instance current : instruction(in_opcode: (current_op),
  	   	     		 in_latencies: (current_latencies),
				 execute: (progress));
  instance subsequent : instruction(in_opcode: (subsequent_op),
  	   	      		    in_latencies: (subsequent_latencies),
			            execute: (true));

  var initialized: boolean;
  
  procedure inst_ready (instruction:isa.inst_t) 
  modifies is_inst_ready, is_branch_pending, is_ninst_ready,
  	   is_store_pending, is_mem_pending, is_data_dependant;
  {
    is_inst_ready = false;

    case
      (instruction.stage == pre) : { call branch_pending();
  			    	     call next_inst_ready();
  				     call mem_pending();
  				     is_inst_ready  = !is_branch_pending &&
				     	     	      is_ninst_ready &&
						      !is_mem_pending;
    				   }
      (instruction.stage == ID)  : { call data_dependant();
				     is_inst_ready = !is_data_dependant;
				   }
      (instruction.stage == EX)  : { if ((instruction.opcode != load_op) &&
      			    	         (instruction.opcode != store_op)) {
					   call store_pending();
					   is_inst_ready = !is_store_pending;
				     }
    				   }
      (instruction.stage == MEM) : { if (instruction.opcode == store_op)
      			    	       { is_inst_ready = true; }
				   }
      (instruction.stage == IF || instruction.stage == ST || instruction.stage == WB) : {
      			       	     is_inst_ready = true;
				   }
    esac
  }

  // Should try with an array of subsequent instructions
  procedure nstage_wbe_free ()
  modifies is_nstage_wbe_free;
  {
    is_nstage_wbe_free = true;
    
    case
      (current.instruction.stage == MEM)  : { if (subsequent.instruction.stage == ST &&
      				    	      	  subsequent.instruction.var_latencies.st > 1 &&
      				    	      	  current.instruction.opcode == store_op) {
						  is_nstage_wbe_free = false;
					       }
					       if (subsequent.instruction.stage == WB &&
      				    	      	  subsequent.instruction.fixed_latencies.wb > 1 &&
      				    	      	  current.instruction.opcode != store_op) {
						  is_nstage_wbe_free = false;
					       }
					    }
      (current.instruction.stage == EX)   : { if (subsequent.instruction.stage == MEM &&
      				    	      	  subsequent.instruction.var_latencies.mem > 1) {
						  is_nstage_wbe_free = false;
					      }
					    }
	// We probably do not need to check that current.instruction.opcode is a nop
      (current.instruction.stage == ID)   : { if (subsequent.instruction.stage == EX &&
      				    	      	  subsequent.instruction.fixed_latencies.ex > 1) {
						  is_nstage_wbe_free = false;
					      }
					    }
      (current.instruction.stage == IF)   : { if (subsequent.instruction.stage == ID &&
      				    	      	  subsequent.instruction.fixed_latencies.id > 1) {
						  is_nstage_wbe_free = false;
					      }
					    }
      (current.instruction.stage == pre)  : { if (subsequent.instruction.stage == IF &&
      				    	      	  subsequent.instruction.var_latencies.fetch > 1) {
						  is_nstage_wbe_free = false;
					      }
   					    }
   esac

   // This is useless for now as long as we only have 2 instructions
   // For more instructions, we need to implement another procedure 
   //call ready(subsequent.instruction);
   // if (ready_ins)
   // {
   //    call (stage_next_free) = will_be_free(subsequent.instruction);
   //}
  }

  procedure next_inst_ready () modifies is_ninst_ready;
  {
    is_ninst_ready = false;
    
    if (current.instruction.stage == pre)
    {
      var in_pre : boolean;
      in_pre = false;      

      if (subsequent.instruction.stage != pre)
      {
  	  in_pre = true;
      }
      
      if (in_pre) { is_ninst_ready = true; }
    }  
  }

  procedure branch_pending () modifies is_branch_pending;
  {
    is_branch_pending = false;

    if (subsequent.instruction.opcode == branch_op &&
        (subsequent.instruction.stage == IF ||
  	 subsequent.instruction.stage == ID ||
  	 (subsequent.instruction.stage == EX &&
	  subsequent.instruction.fixed_latencies.ex > 1))) {
  	is_branch_pending = true;
    }
  }

  procedure mem_pending () modifies is_mem_pending, is_store_pending;
  {
    var load : boolean;

    is_store_pending = false;
    is_mem_pending = false;

    load = false;
    
    if (subsequent.instruction.opcode == load_op &&
      	(subsequent.instruction.stage == IF ||
  	 subsequent.instruction.stage == ID ||
  	 subsequent.instruction.stage == EX || 
  	 (subsequent.instruction.stage == MEM &&
	  subsequent.instruction.var_latencies.mem > 1)))  {
  	load = true;
    }

    call store_pending();

    is_mem_pending = is_store_pending || load;
  }

  procedure store_pending () modifies is_store_pending;
  {
    is_store_pending = false;

    if (subsequent.instruction.opcode == store_op &&
        (subsequent.instruction.stage == IF ||
  	 subsequent.instruction.stage == ID ||
  	 subsequent.instruction.stage == EX ||
  	 subsequent.instruction.stage == MEM ||
	 (subsequent.instruction.stage == ST && 	 
          subsequent.instruction.var_latencies.st > 1))) {
  	is_store_pending = true;
    }   
  }

  // Seems that this rule is useless in fact, as mem_pending ensures this!
  // Conclusion: SIC is a PRET architecture where the slot between instructions
  // is computed dynamically ... However SIC does not allow other thread to go in
  // => Mixing PRET and SIC should be great!
  procedure data_dependant () modifies is_data_dependant;
  {
    is_data_dependant = false;

    if (subsequent.instruction.opcode == load_op &&
      	(subsequent.instruction.stage == IF ||
  	 subsequent.instruction.stage == ID ||
  	 subsequent.instruction.stage == EX ||
  	 (subsequent.instruction.stage == MEM &&
	  subsequent.instruction.var_latencies.mem > 1))) {
       if (current.instruction.src_regs.src1 == subsequent.instruction.dst_reg ||
  	   current.instruction.src_regs.src2 == subsequent.instruction.dst_reg) {
  	  is_data_dependant = true;
       }
    }
  }

  init {
    progress = false;
    initialized = false;
  }

  procedure update_progress()
  modifies progress, is_inst_ready, is_mem_pending, is_ninst_ready,
  	   is_store_pending, is_branch_pending, is_data_dependant, is_nstage_wbe_free;
  {
    call inst_ready(current.instruction);
    call nstage_wbe_free();

    progress = is_inst_ready && is_nstage_wbe_free;
  }

  // Updating the state of the instruction
  next  {
    if (!initialized) {
	assume(current.instruction.opcode == current_op);
	assume(subsequent.instruction.opcode == subsequent_op);	
        assume(current.instruction.var_latencies == current_latencies);
        assume(subsequent.instruction.var_latencies == subsequent_latencies);
        assume(current.instruction.src_regs == current_src);
        assume(current.instruction.dst_reg == current_dst);
        assume(subsequent.instruction.src_regs == subsequent_src);
        assume(subsequent.instruction.dst_reg == subsequent_dst);		
    	initialized' = true;
      	next(subsequent);	
    } else {
      	call update_progress();
	next(subsequent); 	
    	if (progress) { next(current);}
    }
  }
}

module main {
  var step : integer;

  var op0, op1: isa.opcode_t;
  var latencies0, latencies1: isa.var_latency_t;
  var src0, src1: isa.src_regs_t;
  var dst0, dst1: isa.reg_t;    

  // As much as instance as subsequent instruction can have an impact of the current one
  // By definition, this number is limited by the number of stages of a pipeline, no?

  instance pipeline : sic(current_op: (op0), subsequent_op: (op1),
  	   	          current_latencies: (latencies0), subsequent_latencies: (latencies1),
			  current_src: (src0), current_dst: (dst0),
			  subsequent_src: (src1), subsequent_dst: (dst1));
  
  init {
    step = 0;
    // Test the stalling logic due to branch op
    op0 = other_op;
    op1 = branch_op;
    // Test the stalling logic due to mem op
    // op0 = other_op;
    // op1 = store_op;//load_op
    // Test the stalling logic due to data dependencies
    // op0 = other_op;
    // op1 = load_op;
    // Test the next stage ready logic (in stage pre for current)
    // op0 = other_op;
    // op1 = other_op;
    // Test the next stage ready logic (in stage store for current)
    // op0 = other_op;
    // op1 = store_op;        
    latencies0.fetch = 1;
    latencies0.mem = 1;
    latencies0.st = 1;
    // Test the next stage ready logic (in stage pre for current)    
    //latencies1.fetch = 3;
    latencies1.fetch = 1;
    latencies1.mem = 1;
    latencies1.st = 1;
    // Test the next stage ready logic (in stage post for current)        
    //latencies1.st = 3;    
    // Values for a data dependency to occur
    // src0.src1 = 3bv5;
    // src0.src2 = 4bv5;
    // dst0 = 5bv5;    
    // src1.src1 = 1bv5;
    // src1.src2 = 2bv5;
    // dst1 = 3bv5;
    // No data dependency
    src0.src1 = 4bv5;
    src0.src2 = 5bv5;
    dst0 = 6bv5;    
    src1.src1 = 1bv5;
    src1.src2 = 2bv5;
    dst1 = 3bv5;    
  }

  next {
    step' = step + 1;
    next(pipeline);
  }

  // The property we are looking at (our paper at WCET 2018?)
  invariant no_timing_anomalies: step < 15;
//  property no_tming_anomalies: G();
  
  // Bounded model checking limit
  control {
//    vobj = bmc[no_timing_anomalies](4);
    vobj = unroll(15);
    check;
    print_results;
    vobj.print_cex(step, pipeline.progress, pipeline.is_inst_ready, pipeline.is_nstage_wbe_free,
    		   pipeline.is_branch_pending, pipeline.is_ninst_ready, pipeline.is_mem_pending,
		   pipeline.is_store_pending, pipeline.is_data_dependant,
		   pipeline.current.instruction, pipeline.subsequent.instruction,
		   pipeline.current.delays, pipeline.subsequent.delays);
    // Dump a VCD file seems to work only for boolean values, not useful ...
    vobj.dump_cex_vcds;
  }
}
	


