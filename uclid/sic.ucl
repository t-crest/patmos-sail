// Model of SIC (strictly in-order pipeline)
// We remove any latency information in the model which add nothing

// check the pipeline: uclid -m pipeline sic.ucl
// run with some instructions: uclid sic.ucl

// TODO
// - Enhance ready it to monitor delays an instruction
//   is going to suffer from due to previous and subsequent instructions   
// - Specify the invariant property: basically checking that delays due
//   subsequent instructions is always 0
// - Use latency to setup the example of the paper
// - Remove rules to get a classical in-order pipeline

// We were unable to model using an array of record using UCLID
// Arrays of values works well, but we want to update a subset of an element
// of an array -> TLA+ seems better here.

// In an in-order pipeline, instruction i can be blocked by a
// subsequent instruction j (j>i) while j is in fetch stage. In SIC,
// this is avoided as 

module param {
  // The length of the tace
  const trace_length: integer = 8;
}

module isa {
  // Words -- Addresses, Data, etc.
  type word_t = bv32;

  // Pipeline stages
  type stage_t = enum { pre, IF, ID, EX, MEM, ST, WB, post };

  // Opcode 
  type opcode_t = enum { nop, load_op, store_op, branch_op, other_op };

  // Latencies information for each instruction
  type latency_t = record { fetch: integer, mem: integer, st: integer };

  // Delay suffered by each instruction
  type delay_t = record { previous: integer, subsequent: integer };

  // Instruction 
  type inst_t = record { opcode: opcode_t,
			 latencies: latency_t,
			 stage: stage_t };
}

module instruction {

  // To set the values for the latencies, we need both an input and a var
  // as input are readonly variables ...
  input in_latencies: isa.latency_t;
  // The opcode which is set
  input in_opcode: isa.opcode_t;
  // Used in this module as read only values 
  input execute: boolean;

  // The instruction
  var instruction: isa.inst_t;

  // To allow the main module to retrieve values and check delays
  output delays: isa.delay_t;

  init {
    instruction.stage = pre;
    delays.previous = 0;
    delays.subsequent = 0;
  }
  
  procedure update_IF() modifies instruction; {
    instruction.latencies.fetch = instruction.latencies.fetch - 1;
  }

  procedure update_MEM() modifies instruction; {
    instruction.latencies.mem = instruction.latencies.mem - 1;
  }

  procedure update_ST() modifies instruction; {
    instruction.latencies.st = instruction.latencies.st - 1;
  }

  procedure update_stage() modifies instruction; {
       case
	  (instruction.stage == pre) : { instruction.stage = IF; }
	  (instruction.stage == IF)  : { if (instruction.latencies.fetch == 0)
	  		     	       	   { instruction.stage = ID; }
	  	    	     		 else { call update_IF() ; }}
	  (instruction.stage == ID)  : { if (instruction.opcode != nop)
	  		     	       	   { instruction.stage = EX; }
	  	    	     		 else { instruction.stage = post; }}
	  (instruction.stage == EX)  : { instruction.stage = MEM; }
	  (instruction.stage == MEM) : { if (instruction.latencies.mem == 0) {
	  	    	     	       	   if (instruction.opcode == store_op)
					   { instruction.stage = ST; }
	  		     		   else { instruction.stage = WB; } }
			     		 else { call update_MEM(); }
	  		   	       }
	  (instruction.stage == ST)  : { if (instruction.latencies.st == 0)
	  		     	       	   { instruction.stage = post; }
			     		 else { call update_ST(); }
			   		 }
	  (instruction.stage == WB ) : { instruction.stage = post; }
      esac
  }

  next {
    if (execute) {
      call update_stage();
    } 
  }
}

module sic {

  input current_op, subsequent_op: isa.opcode_t;
  input current_latencies, subsequent_latencies: isa.latency_t;

  var progress: boolean;

  instance current_ins : instruction(in_opcode: (current_op),
  	   	     		     in_latencies: (current_latencies),
				     execute: (progress));
  instance subsequent_ins : instruction(in_opcode: (subsequent_op),
  	   	      		  	in_latencies: (subsequent_latencies),
					execute: (true));

  var initialized: boolean;
  
  procedure ready (instruction:isa.inst_t) returns (b:boolean)
  {
    var mem_ready, ex_ready, /* id_ready,  */pre_ready : boolean;

    var opc:isa.opcode_t;

    mem_ready = false;
    ex_ready = false;
    
    opc = instruction.opcode;

    if (instruction.stage == MEM && opc == store_op) { mem_ready = true; }
    
    if (instruction.stage == EX && ((opc != load_op) && (opc != store_op)))
    {
  	var store : boolean;

  	call (store) = store_pending(instruction);
  	ex_ready = !store;
    }

    /* if (instruction.stage == ID) */
    /* { */
    /* 	var stall : boolean; */

    /* 	call (stall) = data_dependant(instruction); */
    /* 	id_ready = !stall; */
    /* } */

    if (instruction.stage == pre)
    {
  	var next_ins, branch, mem : boolean;
  	call (branch) = branch_pending(instruction);
  	call (next_ins) = next_instruction(instruction);
  	call (mem) = mem_pending(instruction);
  	pre_ready = !branch && next_ins && !mem;
    }

    b = mem_ready || ex_ready /* || id_ready */ || pre_ready;
  }

  procedure will_be_free (instruction:isa.inst_t) returns (b:boolean)
  {
    var executed, stage_occupied, stage_next_free: boolean;
    
    executed = false;
    stage_occupied = false;
    stage_next_free = false;

    if (instruction.stage == post) { executed = true; } 

    if (instruction.stage == subsequent_ins.instruction.stage)
    {
	var ready_ins : boolean;	
	
  	stage_occupied = true;
	  
  	call (ready_ins) = ready(subsequent_ins.instruction);
	  
  	// if (ready_ins)
  	// {
	//    call (stage_next_free) = will_be_free(subsequent_ins.instruction);
  	//}
    }

    b = executed || !stage_occupied || stage_next_free;
  }

  // next is a keyword in uclid!
  procedure next_instruction (instruction:isa.inst_t) returns (b:boolean)
  {
    b = false;
    
    if (instruction.stage == pre)
    {
      var in_pre : boolean;
      in_pre = false;      

      if (subsequent_ins.instruction.stage == pre)
      {
  	  in_pre = true;
      }
      
      if (!in_pre) { b = true; }
    }  
  }

  procedure branch_pending (instruction: isa.inst_t) returns (b:boolean)
  {
    b = false;

    if (subsequent_ins.instruction.opcode == branch_op &&
        (subsequent_ins.instruction.stage == IF ||
  	 subsequent_ins.instruction.stage == ID ||
  	 subsequent_ins.instruction.stage == EX)) {
  	b = true;
    }
  }

  procedure mem_pending (instruction: isa.inst_t) returns (b:boolean)
  {
    var store, load : boolean;

    store = false;
    load = false;
    b = false;
    
    if (subsequent_ins.instruction.opcode == load_op &&
      	(subsequent_ins.instruction.stage == IF ||
  	 subsequent_ins.instruction.stage == ID ||
  	 subsequent_ins.instruction.stage == EX ||
  	 subsequent_ins.instruction.stage == MEM))  {
  	load = true;
    }

    call (store) = store_pending(instruction);

    b = store || load;
  }

  procedure store_pending (instruction: isa.inst_t) returns (b:boolean)
  {
    b = false;

    if (subsequent_ins.instruction.opcode == store_op &&
        (subsequent_ins.instruction.stage == IF ||
  	 subsequent_ins.instruction.stage == ID ||
  	 subsequent_ins.instruction.stage == EX ||
  	 subsequent_ins.instruction.stage == MEM ||
  	 subsequent_ins.instruction.stage == ST)) {
  	b = true;
    }   
  }

  /* procedure data_dependant (instruction: isa.inst_t) returns (b:boolean) */
  /* { */
  /*   b = false; */

  /*   // TODO: the upper bound should be set to instruction.position. */
  /*   // but was currently unable to express it like this ... */
  /*   for (j : integer) in range (0, param.trace_length) */
  /*   { */
  /*     var other_ins : isa.inst_t; */

  /*     other_ins = instructions[j];     */
  /*     if (other_ins.opcode == load_op && */
  /*     	  (other_ins.stage == IF || */
  /* 	   other_ins.stage == ID || */
  /* 	   other_ins.stage == EX || */
  /* 	   other_ins.stage == MEM)) */
  /*     { */
  /* 	if (instruction.srcs.src1 == other_ins.dst || */
  /* 	    instruction.srcs.src2 == other_ins.dst) */
  /* 	{ */
  /* 	  b = true; */
  /* 	} */
  /*     } */
  /*   }    */
  /* } */

  init {
    progress = false;
    initialized = false;
  }

  procedure update_progress() modifies progress; {
    var is_ready : boolean;
    var is_free : boolean;

    call (is_ready) = ready(current_ins.instruction);
    call (is_free) = will_be_free(current_ins.instruction);

    //progress = is_ready && is_free;
    progress = true;    
}

  // Updating the state of the instruction
  next  {
    if (!initialized) {
	assume(current_ins.instruction.opcode == current_op);
	assume(subsequent_ins.instruction.opcode == subsequent_op);	
        assume(current_ins.instruction.latencies == current_latencies);
        assume(subsequent_ins.instruction.latencies == subsequent_latencies);	
    	initialized' = true;
	} else {
    call update_progress();
    if (progress) { next(subsequent_ins); next(current_ins);}
    }
  }
}

module main {
  var step : integer;

  var op0, op1: isa.opcode_t;
  var latencies0, latencies1: isa.latency_t;

  // As much as instance as subsequent instruction can have an impact of the current one
  // By definition, this number is limited by the number of stages of a pipeline, no?

  instance pipeline : sic(current_op: (op0), subsequent_op: (op1),
  	   	          current_latencies: (latencies0), subsequent_latencies: (latencies1));
  
  init {
    step = 0;
    op0 = store_op;
    op1 = other_op;
    latencies0.fetch = 2;
    latencies0.mem = 2;
    latencies0.st = 2;    
    latencies1.fetch = 1;
    latencies1.mem = 0;
    latencies1.st = 0;        
  }

  next {
    step' = step + 1;
    next(pipeline);
  }

  // The property we are looking at (our paper at WCET 2018?)
  invariant no_timing_anomalies: step < 10;
//  property no_tming_anomalies: G();
  
  // Bounded model checking limit
  control {
//    vobj = bmc[no_timing_anomalies](4);
    vobj = unroll(10);
    check;
    print_results;
    vobj.print_cex(step, pipeline.progress, 
		   pipeline.current_ins.instruction, pipeline.subsequent_ins.instruction,
		   pipeline.current_ins.delays, pipeline.subsequent_ins.delays);		   
  }
}
	


