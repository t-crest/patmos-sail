// Model of SIC (strictly in-order pipeline)
// We remove any latency information in the model which add nothing

// check the pipeline: uclid -m pipeline sic.ucl
// run with some instructions: uclid sic.ucl

// TODO
// - Enhance ready it to monitor delays an instruction
//   is going to suffer from due to previous and subsequent instructions   
// - Specify the invariant property: basically checking that delays due
//   subsequent instructions is always 0
// - Use latency to setup the example of the paper
// - Remove rules to get a classical in-order pipeline

// We were unable to model using an array of record using UCLID
// Arrays of values works well, but we want to update a subset of an element
// of an array -> TLA+ seems better here.

// In an in-order pipeline, instruction i can be blocked by a
// subsequent instruction j (j>i) while j is in fetch stage. In SIC,
// this is avoided as 

module param {
  // The length of the tace
  const trace_length: integer = 8;
}

module isa {
  // Words -- Addresses, Data, etc.
  type word_t = bv32;

  // Pipeline stages
  type stage_t = enum { pre, IF, ID, EX, MEM, ST, WB, post };

  // Opcode 
  type opcode_t = enum { nop, load_op, store_op, branch_op, other_op };

  // Registers. 5 bits to allow 32 registers
  type reg_t = bv5;

  // Source registers
  type src_regs_t = record { src1: reg_t, src2: reg_t };

  // Variable latencies for each instruction
  type var_latency_t = record { fetch: integer, mem: integer, st: integer };

  // Latencies information for each instruction
  type fixed_latency_t = record { id: integer, ex: integer, wb: integer };

  // Delay suffered by each instruction
  type delay_t = record { previous: integer, subsequent: integer };

  // Instruction 
  type inst_t = record { opcode: opcode_t,
			 var_latencies: var_latency_t,
			 src_regs: src_regs_t,
			 dst_reg: reg_t,
			 fixed_latencies: fixed_latency_t,			 
			 stage: stage_t };
}

module instruction {

  // To set the values for the latencies, we need both an input and a var
  // as input are readonly variables ...
  input in_latencies: isa.var_latency_t;
  // The opcode which is set
  input in_opcode: isa.opcode_t;
  // Used in this module as read only values 
  input execute: boolean;

  // The instruction
  var instruction: isa.inst_t;

  // To allow the main module to retrieve values and check delays
  output delays: isa.delay_t;

  init {
    instruction.stage = pre;
    instruction.fixed_latencies.id = 1;
    instruction.fixed_latencies.ex = 1;
    instruction.fixed_latencies.wb = 1;    
    delays.previous = 0;
    delays.subsequent = 0;
  }
  
  procedure latency_IF() modifies instruction; {
    instruction.var_latencies.fetch = instruction.var_latencies.fetch - 1;
  }

  procedure latency_MEM() modifies instruction; {
    instruction.var_latencies.mem = instruction.var_latencies.mem - 1;
  }

  procedure latency_ST() modifies instruction; {
    instruction.var_latencies.st = instruction.var_latencies.st - 1;
  }

  procedure latency_ID() modifies instruction; {
    instruction.fixed_latencies.id = instruction.fixed_latencies.id - 1;
  }

  procedure latency_EX() modifies instruction; {
    instruction.fixed_latencies.ex = instruction.fixed_latencies.ex - 1;
  }

  procedure latency_WB() modifies instruction; {
    instruction.fixed_latencies.wb = instruction.fixed_latencies.wb - 1;
  }

  procedure update_stage() modifies instruction; {
       case
	  (instruction.stage == pre) : { instruction.stage = IF; }
	  (instruction.stage == IF)  : { if (instruction.var_latencies.fetch == 0)
	  		     	       	   { instruction.stage = ID; }
	  	    	     		 else { call latency_IF(); }
				       }
	  (instruction.stage == ID)  : { if (instruction.fixed_latencies.id == 0) {
	  		     	       	   if (instruction.opcode != nop)
					      { instruction.stage = EX; }
	  	    	     		   else { instruction.stage = post; }
					 } else { call latency_ID(); }
				       }
	  (instruction.stage == EX)  : { if (instruction.fixed_latencies.ex == 0) {
	  		     	       	    instruction.stage = MEM;
					 } else { call latency_EX(); }
				       }
	  (instruction.stage == MEM) : { if (instruction.var_latencies.mem == 0) {
	  	    	     	       	   if (instruction.opcode == store_op)
					   { instruction.stage = ST; }
	  		     		   else { instruction.stage = WB; }
			     		 } else { call latency_MEM(); }
	  		   	       }
	  (instruction.stage == ST)  : { if (instruction.var_latencies.st == 0)
	  		     	       	   { instruction.stage = post; }
			     		 else { call latency_ST(); }
			   	       }
	  (instruction.stage == WB ) : { if (instruction.fixed_latencies.wb == 0) {
	  		     	       	    instruction.stage = post;
					  } else  { call latency_WB(); }
				       }
      esac
  }

  next {
    if (execute) {
      call update_stage();
    } 
  }
}

module sic {

  input current_op, subsequent_op: isa.opcode_t;
  input current_latencies, subsequent_latencies: isa.var_latency_t;
  input current_src, subsequent_src: isa.src_regs_t;
  input current_dst, subsequent_dst: isa.reg_t;  

  // Even if this is ugly, this allows to print the value of each
  // variable in the counter-example ...
  var progress: boolean;
  var is_ready : boolean;
  var is_free : boolean;
  
  var is_branch_pending : boolean;
  var is_next_ready: boolean;
  var is_mem_pending: boolean;
  var is_store_pending: boolean;
  var is_data_dependant: boolean;

  instance current : instruction(in_opcode: (current_op),
  	   	     		 in_latencies: (current_latencies),
				 execute: (progress));
  instance subsequent : instruction(in_opcode: (subsequent_op),
  	   	      		    in_latencies: (subsequent_latencies),
			            execute: (true));

  var initialized: boolean;
  
  procedure ready (instruction:isa.inst_t) 
  modifies is_ready, is_branch_pending, is_next_ready,
  	   is_store_pending, is_mem_pending, is_data_dependant;
  {
    is_ready = false;

    case
      (instruction.stage == pre) : { call branch_pending();
  			    	     call next_ready();
  				     call mem_pending();
  				     is_ready  = !is_branch_pending &&
				     	       	 is_next_ready &&
						 !is_mem_pending;
    				   }
      (instruction.stage == ID)  : { call data_dependant();
				     is_ready = !is_data_dependant;
				   }
      (instruction.stage == EX)  : { if ((instruction.opcode != load_op) &&
      			    	         (instruction.opcode != store_op)) {
					   call store_pending();
					   is_ready = !is_store_pending;
				     }
    				   }
      (instruction.stage == MEM) : { if (instruction.opcode == store_op)
      			    	       { is_ready = true; }
				   }
      (instruction.stage == IF || instruction.stage == ST || instruction.stage == WB) : {
      			       	     is_ready = true;
				   }
    esac
  }
				   
  // procedure will_be_free (instruction:isa.inst_t) returns (b:boolean) modifies is_branch_pending;
  // {
  //   var executed, stage_occupied, stage_next_free: boolean;
    
  //   executed = false;
  //   stage_occupied = false;
  //   stage_next_free = false;

  //   if (instruction.stage == post) { executed = true; } 

  //   if (instruction.stage == subsequent.instruction.stage)
  //   {
  // 	var ready_ins : boolean;	
	
  // 	stage_occupied = true;
	  
  // 	call ready(subsequent.instruction);
	  
  // 	// if (ready_ins)
  // 	// {
  // 	//    call (stage_next_free) = will_be_free(subsequent.instruction);
  // 	//}
  //   }

  //   b = executed || !stage_occupied || stage_next_free;
  // }

  // next is a keyword in uclid!
  procedure next_ready () modifies is_next_ready;
  {
    is_next_ready = false;
    
    if (current.instruction.stage == pre)
    {
      var in_pre : boolean;
      in_pre = false;      

      if (subsequent.instruction.stage != pre)
      {
  	  in_pre = true;
      }
      
      if (in_pre) { is_next_ready = true; }
    }  
  }

  procedure branch_pending () modifies is_branch_pending;
  {
    is_branch_pending = false;

    if (subsequent.instruction.opcode == branch_op &&
        (subsequent.instruction.stage == IF ||
  	 subsequent.instruction.stage == ID
	 /* Hardware delays ...
  	 /* || subsequent.instruction.stage == EX*/)) {
  	is_branch_pending = true;
    }
  }

  procedure mem_pending () modifies is_mem_pending, is_store_pending;
  {
    var load : boolean;

    is_store_pending = false;
    is_mem_pending = false;

    load = false;
    
    if (subsequent.instruction.opcode == load_op &&
      	(subsequent.instruction.stage == IF ||
  	 subsequent.instruction.stage == ID ||
  	 subsequent.instruction.stage == EX
	 /* Hardware delays ...
  	 /* || subsequent.instruction.stage == MEM*/))  {
  	load = true;
    }

    call store_pending();

    is_mem_pending = is_store_pending || load;
  }

  procedure store_pending () modifies is_store_pending;
  {
    is_store_pending = false;

    if (subsequent.instruction.opcode == store_op &&
        (subsequent.instruction.stage == IF ||
  	 subsequent.instruction.stage == ID ||
  	 subsequent.instruction.stage == EX ||
  	 subsequent.instruction.stage == MEM
	 /* Hardware delays ...
  	 /* || subsequent.instruction.stage == ST*/)) {
  	is_store_pending = true;
    }   
  }

  // Seems that this rule is useless in fact, as mem_pending ensures this!
  // Conclusion: SIC is a PRET architecture where the slot between instructions
  // is computed dynamically ... However SIC does not allow other thread to go in
  // => Mixing PRET and SIC should be great!
  procedure data_dependant () modifies is_data_dependant;
  {
    is_data_dependant = false;

    if (subsequent.instruction.opcode == load_op &&
      	(subsequent.instruction.stage == IF ||
  	 subsequent.instruction.stage == ID ||
  	 subsequent.instruction.stage == EX
	 /* Hardware delays */
  	 /* || subsequent.instruction.stage == MEM*/)) {
       if (current.instruction.src_regs.src1 == subsequent.instruction.dst_reg ||
  	   current.instruction.src_regs.src2 == subsequent.instruction.dst_reg) {
  	  is_data_dependant = true;
       }
    }
  }

  init {
    progress = false;
    initialized = false;
  }

  procedure update_progress()
  modifies progress, is_ready, is_free, is_mem_pending, is_next_ready,
  	   is_store_pending, is_branch_pending, is_data_dependant; {
    call ready(current.instruction);
//    call (is_free) = will_be_free(current.instruction);

    progress = is_ready; //&& is_free;
  }

  // Updating the state of the instruction
  next  {
    if (!initialized) {
	assume(current.instruction.opcode == current_op);
	assume(subsequent.instruction.opcode == subsequent_op);	
        assume(current.instruction.var_latencies == current_latencies);
        assume(subsequent.instruction.var_latencies == subsequent_latencies);
        assume(current.instruction.src_regs == current_src);
        assume(current.instruction.dst_reg == current_dst);
        assume(subsequent.instruction.src_regs == subsequent_src);
        assume(subsequent.instruction.dst_reg == subsequent_dst);		
    	initialized' = true;
      	next(subsequent);	
    } else {
      	call update_progress();
	next(subsequent); 	
    	if (progress) { next(current);}
    }
  }
}

module main {
  var step : integer;

  var op0, op1: isa.opcode_t;
  var latencies0, latencies1: isa.var_latency_t;
  var src0, src1: isa.src_regs_t;
  var dst0, dst1: isa.reg_t;    

  // As much as instance as subsequent instruction can have an impact of the current one
  // By definition, this number is limited by the number of stages of a pipeline, no?

  instance pipeline : sic(current_op: (op0), subsequent_op: (op1),
  	   	          current_latencies: (latencies0), subsequent_latencies: (latencies1),
			  current_src: (src0), current_dst: (dst0),
			  subsequent_src: (src1), subsequent_dst: (dst1));
  
  init {
    step = 0;
    // Test the stalling logic due to branch op
    // op0 = other_op;
    // op1 = branch_op;
    // Test the stalling logic due to mem op
    // op0 = other_op;
    // op1 = store_op;//load_op
    // Test the stalling logic due to data dependencies
    op0 = other_op;
    op1 = load_op;
    latencies0.fetch = 1;
    latencies0.mem = 1;
    latencies0.st = 1;    
    latencies1.fetch = 1;
    latencies1.mem = 1;
    latencies1.st = 1;
    // Values for a data dependency to occur
    src0.src1 = 3bv5;
    src0.src2 = 4bv5;
    dst0 = 5bv5;    
    src1.src1 = 1bv5;
    src1.src2 = 2bv5;
    dst1 = 3bv5;
  }

  next {
    step' = step + 1;
    next(pipeline);
  }

  // The property we are looking at (our paper at WCET 2018?)
  invariant no_timing_anomalies: step < 15;
//  property no_tming_anomalies: G();
  
  // Bounded model checking limit
  control {
//    vobj = bmc[no_timing_anomalies](4);
    vobj = unroll(15);
    check;
    print_results;
    vobj.print_cex(step, pipeline.progress, pipeline.is_ready, pipeline.is_free,
    		   pipeline.is_branch_pending, pipeline.is_next_ready, pipeline.is_mem_pending,
		   pipeline.is_store_pending, pipeline.is_data_dependant,
		   pipeline.current.instruction, pipeline.subsequent.instruction,
		   pipeline.current.delays, pipeline.subsequent.delays);
    // Dump a VCD file seems to work only for boolean values, not useful ...
    vobj.dump_cex_vcds;
  }
}
	


