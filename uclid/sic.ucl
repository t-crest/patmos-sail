// Model of SIC (strictly in-order pipeline)
// We remove any latency information in the model which add nothing

// run it using: uclid -m pipeline sic.ucl

// I tried to implement the model using a module for instruction and a
// module for the pipeline. However this is not pssible as the pipeline
// module would then require to have one instance of instruction per
// instruction which cannot be generalized to any length. Declaring an
// array of instances seems also not possible ...

module pipeline
{
  // Number of instructions in the trace
  const trace_length : integer = 8;

  // Words -- Addresses, Data, etc.
  type word_t = bv32;

  // Pipeline stages
  type stage_t = enum { pre, IF, ID, EX, MEM, ST, WB, post };

  // Opcode 
  type opcode_t = enum { nop, load_op, store_op, branch_op, other_op };

  // Registers
  type reg_t = word_t;

  // Source registers
  type src_regs_t = record { src1: reg_t, src2:reg_t };

  // Instruction 
  type inst_t = record { position: integer,
       	      	       	 opcode: opcode_t,
			 srcs: src_regs_t,
			 dst: reg_t,
			 stage: stage_t };

  // Non-interpreted function to manipule an instruction
  // TODO: needed?
  function inst2opc (instruction:inst_t):opcode_t;
  function inst2ops (instruction:inst_t):src_regs_t;
  function inst2target (instruction:inst_t):reg_t;
  function inst2stage (instruction:inst_t):stage_t;

  // An array of instructions
  var instructions: [integer]inst_t;

  procedure ready (instruction:inst_t) returns (b:boolean)
  {
    var mem_ready, ex_ready, id_ready, pre_ready : boolean;

    var opc:opcode_t;

    mem_ready = false;
    ex_ready = false;
    
    opc = instruction.opcode;

    if (instruction.stage == MEM && opc == store_op) { mem_ready = true; }
    
    if (instruction.stage == EX && ((opc != load_op) && (opc != store_op)))
    {
	var store : boolean;

	call (store) = store_pending(instruction);
	ex_ready = !store;
    }

    if (instruction.stage == ID)
    {
	var stall : boolean;

	call (stall) = data_dependant(instruction);
	id_ready = !stall;
    }

    if (instruction.stage == pre)
    {
	var next_ins, branch, mem : boolean;
	call (branch) = branch_pending(instruction);
	call (next_ins) = next_instruction(instruction);
	call (mem) = mem_pending(instruction);
	pre_ready = !branch && next_ins && !mem;
    }

    b = mem_ready || ex_ready || id_ready || pre_ready;
  }

  procedure will_be_free (instruction:inst_t) returns (b:boolean)
  {
    var executed, stage_occupied, stage_next_free: boolean;
    
    executed = false;
    stage_occupied = false;
    stage_next_free = false;

    if (instruction.stage == post) { executed = true; } 

    for (i : integer) in range (0, trace_length)
    {
	var other_ins : inst_t;

	other_ins = instructions[i];
	if (instruction.stage == other_ins.stage)
	{
	  var ready_ins : boolean;	
	
	  stage_occupied = true;
	  
	  call (ready_ins) = ready(other_ins);
	  
	  if (ready_ins)
	  {
	    call (stage_next_free) = will_be_free(other_ins);
	  }
	}
    }

    b = executed || !stage_occupied || stage_next_free;
  }

  // next is a keyword in uclid!
  procedure next_instruction (instruction:inst_t) returns (b:boolean)
  {
    b = false;
    
    if (instruction.stage == pre)
    {
      var in_pre : boolean;
      in_pre = false;      

      // TODO: the upper bound should be set to instruction.position.
      // but was currently unable to express it like this ...
      for (j : integer) in range (0, trace_length)
      {
	var other_ins : inst_t;

	other_ins = instructions[j];
	if (other_ins.position < instruction.position && other_ins.stage == pre)
	{
	  in_pre = true;
	}
      }
      
      if (!in_pre) { b = true; }
    }  
  }

  procedure branch_pending (instruction: inst_t) returns (b:boolean)
  {
    b = false;

    // TODO: the upper bound should be set to instruction.position.
    // but was currently unable to express it like this ...
    for (j : integer) in range (0, trace_length)
    {
      var other_ins : inst_t;

      other_ins = instructions[j];    
      if (other_ins.opcode == branch_op &&
      	  (other_ins.stage == IF ||
	   other_ins.stage == ID ||
	   other_ins.stage == EX))
      {
	b = true;
      }
    }   
  }

  procedure mem_pending (instruction: inst_t) returns (b:boolean)
  {
    var store, load : boolean;

    store = false;
    load = false;
    b = false;
    
    // TODO: the upper bound should be set to instruction.position.
    // but was currently unable to express it like this ...
    for (j : integer) in range (0, trace_length)
    {
      var other_ins : inst_t;

      other_ins = instructions[j];    
      if (other_ins.opcode == load_op &&
      	  (other_ins.stage == IF ||
	   other_ins.stage == ID ||
	   other_ins.stage == EX ||
	   other_ins.stage == MEM))
      {
	load = true;
      }
    }

    call (store) = store_pending(instruction);

    b = store || load;
  }

  procedure store_pending (instruction: inst_t) returns (b:boolean)
  {
    b = false;

    // TODO: the upper bound should be set to instruction.position.
    // but was currently unable to express it like this ...
    for (j : integer) in range (0, trace_length)
    {
      var other_ins : inst_t;

      other_ins = instructions[j];    
      if (other_ins.opcode == store_op &&
      	  (other_ins.stage == IF ||
	   other_ins.stage == ID ||
	   other_ins.stage == EX ||
	   other_ins.stage == MEM ||
	   other_ins.stage == ST))
      {
	b = true;
      }
    }   
  }

  procedure data_dependant (instruction: inst_t) returns (b:boolean)
  {
    b = false;

    // TODO: the upper bound should be set to instruction.position.
    // but was currently unable to express it like this ...
    for (j : integer) in range (0, trace_length)
    {
      var other_ins : inst_t;

      other_ins = instructions[j];    
      if (other_ins.opcode == load_op &&
      	  (other_ins.stage == IF ||
	   other_ins.stage == ID ||
	   other_ins.stage == EX ||
	   other_ins.stage == MEM))
      {
	if (instruction.srcs.src1 == other_ins.dst ||
	    instruction.srcs.src2 == other_ins.dst)
	{
	  b = true;
	}
      }
    }   
  }

  // Specify the new stage of each instruction
  procedure stage (current_instructions:[integer] inst_t)
    returns (next_instructions:[integer] inst_t)
  {
    for (i : integer) in range (1, trace_length)
    {
	var current_instruction:inst_t;
	var current_stage:stage_t;
	var next_stage:stage_t;

	current_instruction = current_instructions[i];
	current_stage = current_instruction.stage;

	case
	  (current_stage == pre) : { next_stage = IF; }
	  (current_stage == IF)  : { next_stage = ID; }
	  (current_stage == ID)  : { if (current_instruction.opcode != nop)
	  		    	     { next_stage = EX; }
				     else
				     { next_stage = post; }
				   }
	   (current_stage == EX) : { next_stage = MEM; }
	   (current_stage == MEM): { if (current_instruction.opcode == store_op)
	   		     	     { next_stage = ST; }
				     else
				     { next_stage = WB; }
				   }
	    (current_stage == ST): { next_stage = post; }
	    (current_stage == WB): { next_stage = post; }
	    (current_stage == post) : { next_stage = current_stage;}
	 esac
	 
	 current_instruction.stage = next_stage;
	 next_instructions[i] = current_instruction;
    }
  }

  // Simply initialize each instruction
  // with its position and stage
  init
  {
    for (i : integer) in range (1, trace_length)
    {
	var instruction:inst_t;
	instruction.position = i;
	instruction.stage = pre;
	instructions[i] = instruction;
    }
  }

  // Updating the state of the pipeline,
  // i.e. the stage of each instruction
  next
  {
   
    call (instructions ') = stage(instructions);
  }

  // Bounded model checking limit
  control {
    vobj = unroll(10);
    check;
    print_results;
    vobj.print_cex(instructions);
  }
}
	


