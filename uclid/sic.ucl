// Model of SIC (strictly in-order pipeline)

// I tried to implement the model using a module for instruction and a
// module for the pipeline. However this is not pssible as the pipeline
// module would then require to have one instance of instruction per
// instruction which cannot be generalized to any length. Declaring an
// array of instances seems also not possible ...

module pipeline {
  // Words -- Addresses, Data, etc.
  type word_t = bv32;

  // Pipeline stage
  type stage_t = enum { pre, IF, ID, EX, MEM, ST, WB, post };
  
  // Instruction 
  type inst_t = record { position : bv3, stage : stage_t };

  type opcode_t = enum { nop, load, store, cond_branch, other };

  // Registers
  type reg_t = word_t;

  // Source registers
  type src_regs_t = record { src1 : reg_t, src2 : reg_t };
    
  function inst2opc (instruction : inst_t) : opcode_t;
  function inst2ops (instruction : inst_t) : src_regs_t;
  function inst2target (instruction : inst_t) : reg_t;
  function inst2stage (instruction : inst_t) : stage_t;

  var instructions : [bv3]inst_t;

  procedure ready (ins: inst_t) returns (b: boolean)
  {
      var opc : opcode_t;
      var b : boolean;

      opc = inst2opc(ins);
      b = false;

      if ((ins.stage == MEM && opc == store)
      	  || (ins.stage == EX && ((opc != load) || (opc != store)))
	  || (ins.stage == ID)
	  || (ins.stage == pre))
      {
      	 b = true;
      }
  }

  procedure stage (instructions : [bv3]inst_t)
  returns (new_instructions : [bv3]inst_t)
  {
      for i in range(0bv3, 7bv3) {
      	    var current_instruction : inst_t;

            var current_stage : stage_t;
      	    var new_stage : stage_t;

	    current_instruction = instructions[i];
            current_stage = inst2stage(current_instruction);
	    
      	    case
	    (current_stage == pre) : { new_stage = IF; }
	    (current_stage == IF)  : { new_stage = ID; }
	    (current_stage == ID)  : { if (inst2opc(current_instruction) != nop) { new_stage = EX; }
	    		      	       else { new_stage = post; } }	
	    (current_stage == EX)  : { new_stage = MEM; }
	    (current_stage == MEM) : { if (inst2opc(current_instruction) == store) { new_stage = ST; }
	    		      	       else { new_stage = WB; } }
	    (current_stage == ST)  : { new_stage = post; }
	    (current_stage == WB)  : { new_stage = post; }
	    (current_stage == post): { }
      	    esac
	    
	    current_instruction.stage = new_stage;
	    new_instructions[i] = current_instruction;
      }
  }

  init {
    for i in range(0bv3, 7bv3) {
    	var ins : inst_t;
	ins.position = i;
	ins.stage = pre;
    	instructions[i] = ins;
    }
  }

  next {
      call (instructions') = stage(instructions);
  }

  control {
    unroll(10);
    check;
    print_results;
  }
}
	

