// Model of SIC (strictly in-order pipeline)
// We remove any latency information in the model which add nothing

// check the pipeline: uclid -m pipeline sic.ucl
// run with some instructions: uclid sic.ucl

// TODO
// - Enhance ready it to monitor delays an instruction
//   is going to suffer from due to previous and subsequent instructions   
// - Specify the invariant property: basically checking that delays due
//   subsequent instructions is always 0
// - Use latency to setup the example of the paper
// - Remove rules to get a classical in-order pipeline

// In an in-order pipeline, instruction i can be blocked by a
// subsequent instruction j (j>i) while j is in fetch stage. In SIC,
// this is avoided as 

module param {
  // The length of the tace
  const trace_length: integer = 8;
}

module isa {
  // Words -- Addresses, Data, etc.
  type word_t = bv32;

  // Pipeline stages
  type stage_t = enum { pre, IF, ID, EX, MEM, ST, WB, post };

  // Opcode 
  type opcode_t = enum { nop, load_op, store_op, branch_op, other_op };

  // Latencies information for each instruction
  type latency_t = record { fetch: integer, mem: integer, st: integer };

  // Delay suffered by each instruction
  type delay_t = record { previous: integer, subsequent: integer };
}

module instruction {

  // We were unable to model using an array of record using UCLID
  // Arrays of values works well, but we want to update a subset of an element
  // of an array -> TLA+ seems better here.
  // input position: integer;

  // Used in this module as read only values 
  input opcode: isa.opcode_t;
  input execute: boolean;

  // To set the values for the latencies, we need both an input and a var
  // as input are readonly variables ...
  input init_latencies: isa.latency_t;
  var latencies: isa.latency_t;
  // This is to ensure that latencies are properly set to the values we give
  // as inputs
  var initialized: boolean;  

  // To allow the main module to retrieve values and check delays
  output delays: isa.delay_t;

  // Current stage in which the instruction is
  var stage: isa.stage_t;

  init {
    stage = pre;
    initialized = false;
    execute = false;
  }
  
  procedure update_IF() modifies latencies; { latencies.fetch = latencies.fetch - 1;}

  procedure update_MEM() modifies latencies; { latencies.mem = latencies.mem - 1;}

  procedure update_ST() modifies latencies; { latencies.st = latencies.st - 1; }

  next {
    if (execute) {
       case
	  (stage == pre) : { stage' = IF; }
	  (stage == IF)  : { if (latencies.fetch == 0) { stage' = ID; }
	  	    	     else { call update_IF() ; }}
	  (stage == ID)  : { if (opcode != nop) { stage' = EX; }
	  	    	     else { stage' = post; }}
	  (stage == EX)  : { stage' = MEM; }
	  (stage == MEM) : { if (latencies.mem == 0) {
	  	    	     	if (opcode == store_op) { stage' = ST; }
	  		     	else { stage' = WB; } }
			     else { call update_MEM(); }
	  		   }
	  (stage == ST)  : { if (latencies.st == 0) { stage' = post; }
			     else { call update_ST(); }
			   }
	  (stage == WB ) : { stage' = post; }
      esac
    } 
  }
}

module sic {

  input previous_opcode, current_opcode: isa.opcode_t;
  input previous_latencies, current_latencies: isa.latency_t;

  var progress: boolean;
  
  // As much as instance as previous instruction can have an impact of the current one
  // By definition, this number is limited by the number of stages of a pipeline, no?
  instance previous : instruction(opcode: (previous_opcode),
  	   	      		  init_latencies: (previous_latencies),
				  execute: (progress));    

  instance current : instruction(opcode: (current_opcode),
  	   	     		 init_latencies: (current_latencies),
				 execute: (progress));

  procedure ready (instruction:isa.inst_t) returns (b:boolean)
  {
    var mem_ready, ex_ready, /* id_ready,  */pre_ready : boolean;

    var opc:isa.opcode_t;

    mem_ready = false;
    ex_ready = false;
    
    opc = instruction.opcode;

    if (instruction.stage == MEM && opc == store_op) { mem_ready = true; }
    
    if (instruction.stage == EX && ((opc != load_op) && (opc != store_op)))
    {
  	var store : boolean;

  	call (store) = store_pending(instruction);
  	ex_ready = !store;
    }

    /* if (instruction.stage == ID) */
    /* { */
    /* 	var stall : boolean; */

    /* 	call (stall) = data_dependant(instruction); */
    /* 	id_ready = !stall; */
    /* } */

    if (instruction.stage == pre)
    {
  	var next_ins, branch, mem : boolean;
  	call (branch) = branch_pending(instruction);
  	call (next_ins) = next_instruction(instruction);
  	call (mem) = mem_pending(instruction);
  	pre_ready = !branch && next_ins && !mem;
    }

    b = mem_ready || ex_ready /* || id_ready */ || pre_ready;
  }

  procedure will_be_free (instruction:isa.inst_t) returns (b:boolean)
  {
    var executed, stage_occupied, stage_next_free: boolean;
    
    executed = false;
    stage_occupied = false;
    stage_next_free = false;

    if (instruction.stage == post) { executed = true; } 

    if (instruction.stage == previous.stage)
    {
	var ready_ins : boolean;	
	
  	stage_occupied = true;
	  
  	call (ready_ins) = ready(previous);
	  
  	if (ready_ins)
  	{
	   call (stage_next_free) = will_be_free(previous);
  	}
    }

    b = executed || !stage_occupied || stage_next_free;
  }

  // next is a keyword in uclid!
  procedure next_instruction (instruction:isa.inst_t) returns (b:boolean)
  {
    b = false;
    
    if (instruction.stage == pre)
    {
      var in_pre : boolean;
      in_pre = false;      

      if (previous.stage == pre)
      {
  	  in_pre = true;
      }
      
      if (!in_pre) { b = true; }
    }  
  }

  procedure branch_pending (instruction: isa.inst_t) returns (b:boolean)
  {
    b = false;

    if (previous.opcode == branch_op &&
        (previous.stage == IF ||
  	 previous.stage == ID ||
  	 previous.stage == EX)) {
  	b = true;
    }
  }

  procedure mem_pending (instruction: isa.inst_t) returns (b:boolean)
  {
    var store, load : boolean;

    store = false;
    load = false;
    b = false;
    
    if (previous.opcode == load_op &&
      	(previous.stage == IF ||
  	 previous.stage == ID ||
  	 previous.stage == EX ||
  	 previous.stage == MEM))  {
  	load = true;
    }

    call (store) = store_pending(instruction);

    b = store || load;
  }

  procedure store_pending (instruction: isa.inst_t) returns (b:boolean)
  {
    b = false;

    if (previous.opcode == store_op &&
        (previous.stage == IF ||
  	 previous.stage == ID ||
  	 previous.stage == EX ||
  	 previous.stage == MEM ||
  	 previous.stage == ST)) {
  	b = true;
    }   
  }

  /* procedure data_dependant (instruction: isa.inst_t) returns (b:boolean) */
  /* { */
  /*   b = false; */

  /*   // TODO: the upper bound should be set to instruction.position. */
  /*   // but was currently unable to express it like this ... */
  /*   for (j : integer) in range (0, param.trace_length) */
  /*   { */
  /*     var other_ins : isa.inst_t; */

  /*     other_ins = instructions[j];     */
  /*     if (other_ins.opcode == load_op && */
  /*     	  (other_ins.stage == IF || */
  /* 	   other_ins.stage == ID || */
  /* 	   other_ins.stage == EX || */
  /* 	   other_ins.stage == MEM)) */
  /*     { */
  /* 	if (instruction.srcs.src1 == other_ins.dst || */
  /* 	    instruction.srcs.src2 == other_ins.dst) */
  /* 	{ */
  /* 	  b = true; */
  /* 	} */
  /*     } */
  /*   }    */
  /* } */

  init {
       progress = false;
  }

// Updating the state of the instruction
  next  {
    if (!initialized) {
        assume(latencies == init_latencies);
    	initialized' = true;
    } else {
        var is_ready : boolean;
    	var is_free : boolean;

	call (is_ready) = ready(current);
	call (is_free) = will_be_free(current);

	progress = is_ready && is_free;
	next(current);
    }
  }
}

module main {
  var step : integer;

  var op0, op1: isa.opcode_t;
  var latencies_0, latencies_1: isa.latency_t;

  instance pipeline : sic(previous_opcode: (op1), current_opcode : (op0),
  	   	       	  previous_latencies: (latencies_1), current_latencies : (latencies_0))

  init {
    step = 0;
    op0 = store_op;
    op1 = other_op;
    latencies_0.fetch = 2;
    latencies_0.mem = 2;
    latencies_0.st = 2;    
    latencies_1.fetch = 1;
    latencies_1.mem = 0;
    latencies_1.st = 0;        
  }

  next {
    step' = step + 1;
    next(pipeline);
  }

  // The property we are looking at (our paper at WCET 2018?)
  invariant no_timing_anomalies: step < 10;
//  property no_tming_anomalies: G();
  
  // Bounded model checking limit
  control {
//    vobj = bmc[no_timing_anomalies](4);
    vobj = unroll(10);
    check;
    print_results;
    vobj.print_cex(step, ins0.position, ins0.initialized, ins0.stage, ins0.latencies,
    			 ins1.position, ins1.stage, ins1.latencies,
			 ins2.position, ins2.stage, ins2.latencies);
  }
}
	


