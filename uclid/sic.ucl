// Model of SIC (strictly in-order pipeline)
// We remove any latency information in the model which add nothing

// I tried to implement the model using a module for instruction and a
// module for the pipeline. However this is not pssible as the pipeline
// module would then require to have one instance of instruction per
// instruction which cannot be generalized to any length. Declaring an
// array of instances seems also not possible ...

module pipeline
{
  // Words -- Addresses, Data, etc.
  type word_t = bv32;

  // I tried to change bv3 with a custom type to more easily change the
  // trace length, but range function does not accept the new type
  // type trace_length_t = bv3;

  // Pipeline stages
  type stage_t = enum { pre, IF, ID, EX, MEM, ST, WB, post };

  // Instruction 
  type inst_t = record { position: bv3, stage:stage_t };

  // Opcode 
  type opcode_t = enum { nop, load, store, branch, other };

  // Registers
  type reg_t = word_t;

  // Source registers
  type src_regs_t = record { src1: reg_t, src2:reg_t };

  // Non-interpreted function to manipule an instruction
  function inst2opc (instruction:inst_t):opcode_t;
  function inst2ops (instruction:inst_t):src_regs_t;
  function inst2target (instruction:inst_t):reg_t;
  function inst2stage (instruction:inst_t):stage_t;

  // An array of instructions
  var instructions: [bv3]inst_t;

  procedure ready (instruction:inst_t) returns (b:boolean)
  {
    var opc:opcode_t;

    opc = inst2opc (instruction);
    b = false;

    if ((instruction.stage == MEM && opc == store)
	|| (instruction.stage == EX && ((opc != load) || (opc != store)))
	|| (instruction.stage == ID) || (instruction.stage == pre))
      {
	b = true;
      }
  }

  procedure will_be_free (instruction:inst_t) returns (b:boolean)
  {
    var b:boolean
    
  }

  // Specify the new stage of each instruction
  procedure stage (current_instructions:[bv3] inst_t)
    returns (next_instructions:[bv3] inst_t)
  {
    for i in range (0 bv3, 7 bv3)
    {
	var current_instruction:inst_t;
	var current_stage:stage_t;
	var next_stage:stage_t;

	current_instruction = current_instructions[i];
	current_stage = inst2stage (current_instruction);

	case
	  (current_stage == pre) : { next_stage = IF; }
	  (current_stage == IF)  : { next_stage = ID; }
	  (current_stage == ID)  : { if (inst2opc (current_instruction) != nop)
	  		    	     { next_stage = EX; }
				     else
				     { next_stage = post; }
				   }
	   (current_stage == EX) : { next_stage = MEM; }
	   (current_stage == MEM): { if (inst2opc (current_instruction) == store)
	   		     	     { next_stage = ST; }
				     else
				     { next_stage = WB; }
				   }
	    (current_stage == ST): { next_stage = post; }
	    (current_stage == WB): { next_stage = post; }
	    (current_stage == post) : { next_stage = current_stage;}
	 esac
	 
	 current_instruction.stage = next_stage;
	 next_instructions[i] = current_instruction;
    }
  }

  // Simply initialize each instruction
  // with its position and stage
  init
  {
    for i in range (0 bv3, 7 bv3)
    {
	var instruction:inst_t;
	instruction.position = i;
	instruction.stage = pre;
	instructions[i] = instruction;
    }
  }

  // Updating the state of the pipeline,
  // i.e. the stage of each instruction
  next
  {
   
    call (instructions ') = stage(instructions);
  }

  // Bounded model checking limit
  control {
    vobj = unroll(10);
    check;
    print_results;
    vobj.print_cex(instructions);
  }
}
	


