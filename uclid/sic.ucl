// Model of SIC (strictly in-order pipeline)
// We remove any latency information in the model which add nothing

// run it using: uclid -m pipeline sic.ucl

// I tried to implement the model using a module for instruction and a
// module for the pipeline. However this is not pssible as the pipeline
// module would then require to have one instance of instruction per
// instruction which cannot be generalized to any length. Declaring an
// array of instances seems also not possible ...

module pipeline
{
  // Number of instructions in the trace
  const trace_length : integer = 8;

  // Words -- Addresses, Data, etc.
  type word_t = bv32;

  // Pipeline stages
  type stage_t = enum { pre, IF, ID, EX, MEM, ST, WB, post };

  // Instruction 
  type inst_t = record { position: integer, stage:stage_t };

  // Opcode 
  type opcode_t = enum { nop, load, store, branch, other };

  // Registers
  type reg_t = word_t;

  // Source registers
  type src_regs_t = record { src1: reg_t, src2:reg_t };

  // Non-interpreted function to manipule an instruction
  function inst2opc (instruction:inst_t):opcode_t;
  function inst2ops (instruction:inst_t):src_regs_t;
  function inst2target (instruction:inst_t):reg_t;
  function inst2stage (instruction:inst_t):stage_t;

  // An array of instructions
  var instructions: [integer]inst_t;

  procedure ready (instruction:inst_t) returns (b:boolean)
  {
    var opc:opcode_t;

    opc = inst2opc (instruction);
    b = false;

    if ((instruction.stage == MEM && opc == store)
	|| (instruction.stage == EX && ((opc != load) || (opc != store)))
	|| (instruction.stage == ID) || (instruction.stage == pre))
      {
	b = true;
      }
  }

  procedure will_be_free (instruction:inst_t) returns (b:boolean)
  {
     b = true;
     
     if (instruction.stage != post) { b = false; }
     else
     {
       for (i : integer) in range (0, trace_length)
       {
         var other_instruction : inst_t;

         other_instruction = instructions[i];
         if (other_instruction == instruction_stage) { b = true; }
       }
     }    
  }

  // next is a keyword in uclid!
  procedure next_instruction (instruction:inst_t) returns (b:boolean)
  {
    if (instruction.stage == pre) { b = true; } else { b = false; }
  }

  procedure branch_pending (instruction: inst_t) returns (b:boolean)
  {

  }

  procedure load_pending (instruction: inst_t) returns (b:boolean)
  {

  }

  procedure store_pending (instruction: inst_t) returns (b:boolean)
  {

  }

  procedure data_dependant (instruction: inst_t) returns (b:boolean)
  {

  }

  // Specify the new stage of each instruction
  procedure stage (current_instructions:[integer] inst_t)
    returns (next_instructions:[integer] inst_t)
  {
    for (i : integer) in range (1, trace_length)
    {
	var current_instruction:inst_t;
	var current_stage:stage_t;
	var next_stage:stage_t;

	current_instruction = current_instructions[i];
	current_stage = inst2stage (current_instruction);

	case
	  (current_stage == pre) : { next_stage = IF; }
	  (current_stage == IF)  : { next_stage = ID; }
	  (current_stage == ID)  : { if (inst2opc (current_instruction) != nop)
	  		    	     { next_stage = EX; }
				     else
				     { next_stage = post; }
				   }
	   (current_stage == EX) : { next_stage = MEM; }
	   (current_stage == MEM): { if (inst2opc (current_instruction) == store)
	   		     	     { next_stage = ST; }
				     else
				     { next_stage = WB; }
				   }
	    (current_stage == ST): { next_stage = post; }
	    (current_stage == WB): { next_stage = post; }
	    (current_stage == post) : { next_stage = current_stage;}
	 esac
	 
	 current_instruction.stage = next_stage;
	 next_instructions[i] = current_instruction;
    }
  }

  // Simply initialize each instruction
  // with its position and stage
  init
  {
    for (i : integer) in range (1, trace_length)
    {
	var instruction:inst_t;
	instruction.position = i;
	instruction.stage = pre;
	instructions[i] = instruction;
    }
  }

  // Updating the state of the pipeline,
  // i.e. the stage of each instruction
  next
  {
   
    call (instructions ') = stage(instructions);
  }

  // Bounded model checking limit
  control {
    vobj = unroll(10);
    check;
    print_results;
    vobj.print_cex(instructions);
  }
}
	


