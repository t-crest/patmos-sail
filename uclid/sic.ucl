// Model of SIC (strictly in-order pipeline)
// We remove any latency information in the model which add nothing

// check the pipeline: uclid -m pipeline sic.ucl
// run with some instructions: uclid sic.ucl

// TODO
// - Specify the invariant property
// - Add latencies for instructions
// - Use latency to setup the example of the paper
// - Remove rules to get a classical in-order pipeline

// I tried to implement the model using a module for instruction and a
// module for the pipeline. However this is not pssible as the pipeline
// module would then require to have one instance of instruction per
// instruction which cannot be generalized to any length. Declaring an
// array of instances seems also not possible ...

module param {
  // The length of the tace
  const trace_length: integer = 8;
}

module isa {
  // Words -- Addresses, Data, etc.
  type word_t = bv32;

  // Pipeline stages
  type stage_t = enum { pre, IF, ID, EX, MEM, ST, WB, post };

  // Opcode 
  type opcode_t = enum { nop, load_op, store_op, branch_op, other_op };

  // Remove registers as the data dependency is not important
  /* // Registers */
  /* type reg_t = word_t; */

  /* // Source registers */
  /* type src_regs_t = record { src1: reg_t, src2:reg_t }; */

  // Instruction 
  type inst_t = record { position: integer,
       	      	       	 opcode: opcode_t,
			 /* srcs: src_regs_t, */
			 /* dst: reg_t, */
			 stage: stage_t };
}

module pipeline {
  // An array of instructions
  input instructions: [integer]isa.inst_t;

  procedure ready (instruction:isa.inst_t) returns (b:boolean)
  {
    var mem_ready, ex_ready, /* id_ready,  */pre_ready : boolean;

    var opc:isa.opcode_t;

    mem_ready = false;
    ex_ready = false;
    
    opc = instruction.opcode;

    if (instruction.stage == MEM && opc == store_op) { mem_ready = true; }
    
    if (instruction.stage == EX && ((opc != load_op) && (opc != store_op)))
    {
	var store : boolean;

	call (store) = store_pending(instruction);
	ex_ready = !store;
    }

    /* if (instruction.stage == ID) */
    /* { */
    /* 	var stall : boolean; */

    /* 	call (stall) = data_dependant(instruction); */
    /* 	id_ready = !stall; */
    /* } */

    if (instruction.stage == pre)
    {
	var next_ins, branch, mem : boolean;
	call (branch) = branch_pending(instruction);
	call (next_ins) = next_instruction(instruction);
	call (mem) = mem_pending(instruction);
	pre_ready = !branch && next_ins && !mem;
    }

    b = mem_ready || ex_ready /* || id_ready */ || pre_ready;
  }

  procedure will_be_free (instruction:isa.inst_t) returns (b:boolean)
  {
    var executed, stage_occupied, stage_next_free: boolean;
    
    executed = false;
    stage_occupied = false;
    stage_next_free = false;

    if (instruction.stage == post) { executed = true; } 

    for (i : integer) in range (0, param.trace_length)
    {
	var other_ins : isa.inst_t;

	other_ins = instructions[i];
	if (instruction.stage == other_ins.stage)
	{
	  var ready_ins : boolean;	
	
	  stage_occupied = true;
	  
	  call (ready_ins) = ready(other_ins);
	  
	  if (ready_ins)
	  {
	    call (stage_next_free) = will_be_free(other_ins);
	  }
	}
    }

    b = executed || !stage_occupied || stage_next_free;
  }

  // next is a keyword in uclid!
  procedure next_instruction (instruction:isa.inst_t) returns (b:boolean)
  {
    b = false;
    
    if (instruction.stage == pre)
    {
      var in_pre : boolean;
      in_pre = false;      

      // TODO: the upper bound should be set to instruction.position.
      // but was currently unable to express it like this ...
      for (j : integer) in range (0, param.trace_length)
      {
	var other_ins : isa.inst_t;

	other_ins = instructions[j];
	if (other_ins.position < instruction.position && other_ins.stage == pre)
	{
	  in_pre = true;
	}
      }
      
      if (!in_pre) { b = true; }
    }  
  }

  procedure branch_pending (instruction: isa.inst_t) returns (b:boolean)
  {
    b = false;

    // TODO: the upper bound should be set to instruction.position.
    // but was currently unable to express it like this ...
    for (j : integer) in range (0, param.trace_length)
    {
      var other_ins : isa.inst_t;

      other_ins = instructions[j];    
      if (other_ins.opcode == branch_op &&
      	  (other_ins.stage == IF ||
	   other_ins.stage == ID ||
	   other_ins.stage == EX))
      {
	b = true;
      }
    }   
  }

  procedure mem_pending (instruction: isa.inst_t) returns (b:boolean)
  {
    var store, load : boolean;

    store = false;
    load = false;
    b = false;
    
    // TODO: the upper bound should be set to instruction.position.
    // but was currently unable to express it like this ...
    for (j : integer) in range (0, param.trace_length)
    {
      var other_ins : isa.inst_t;

      other_ins = instructions[j];    
      if (other_ins.opcode == load_op &&
      	  (other_ins.stage == IF ||
	   other_ins.stage == ID ||
	   other_ins.stage == EX ||
	   other_ins.stage == MEM))
      {
	load = true;
      }
    }

    call (store) = store_pending(instruction);

    b = store || load;
  }

  procedure store_pending (instruction: isa.inst_t) returns (b:boolean)
  {
    b = false;

    // TODO: the upper bound should be set to instruction.position.
    // but was currently unable to express it like this ...
    for (j : integer) in range (0, param.trace_length)
    {
      var other_ins : isa.inst_t;

      other_ins = instructions[j];    
      if (other_ins.opcode == store_op &&
      	  (other_ins.stage == IF ||
	   other_ins.stage == ID ||
	   other_ins.stage == EX ||
	   other_ins.stage == MEM ||
	   other_ins.stage == ST))
      {
	b = true;
      }
    }   
  }

  /* procedure data_dependant (instruction: isa.inst_t) returns (b:boolean) */
  /* { */
  /*   b = false; */

  /*   // TODO: the upper bound should be set to instruction.position. */
  /*   // but was currently unable to express it like this ... */
  /*   for (j : integer) in range (0, param.trace_length) */
  /*   { */
  /*     var other_ins : isa.inst_t; */

  /*     other_ins = instructions[j];     */
  /*     if (other_ins.opcode == load_op && */
  /*     	  (other_ins.stage == IF || */
  /* 	   other_ins.stage == ID || */
  /* 	   other_ins.stage == EX || */
  /* 	   other_ins.stage == MEM)) */
  /*     { */
  /* 	if (instruction.srcs.src1 == other_ins.dst || */
  /* 	    instruction.srcs.src2 == other_ins.dst) */
  /* 	{ */
  /* 	  b = true; */
  /* 	} */
  /*     } */
  /*   }    */
  /* } */

  // Specify the new stage of each instruction
  procedure stage (current_instructions:[integer] isa.inst_t)
    returns (next_instructions:[integer] isa.inst_t)
  {
    for (i : integer) in range (1, param.trace_length)
    {
	var current_instruction:isa.inst_t;
	var current_stage:isa.stage_t;
	var next_stage:isa.stage_t;

	current_instruction = current_instructions[i];
	current_stage = current_instruction.stage;

	case
	  (current_stage == pre) : { next_stage = IF; }
	  (current_stage == IF)  : { next_stage = ID; }
	  (current_stage == ID)  : { if (current_instruction.opcode != nop)
	  		    	     { next_stage = EX; }
				     else
				     { next_stage = post; }
				   }
	   (current_stage == EX) : { next_stage = MEM; }
	   (current_stage == MEM): { if (current_instruction.opcode == store_op)
	   		     	     { next_stage = ST; }
				     else
				     { next_stage = WB; }
				   }
	    (current_stage == ST): { next_stage = post; }
	    (current_stage == WB): { next_stage = post; }
	    (current_stage == post) : { next_stage = current_stage;}
	 esac
	 
	 current_instruction.stage = next_stage;
	 next_instructions[i] = current_instruction;
    }
  }

  // Updating the state of the pipeline,
  // i.e. the stage of each instruction
  next
  {
    call (instructions') = stage(instructions);
  }

}

module main {
  var step : integer;
  var instructions: [integer]isa.inst_t;

  var current_ins: isa.inst_t;	

  instance sic : pipeline(instructions: (instructions));

  // Here we basically init each instruction
  init {
    step = 0;
    for (i : integer) in range (1, param.trace_length)
    {
      var current_ins: isa.inst_t;	    
      current_ins.position = i;
      current_ins.stage = pre;

      // Example of the SIC paper
      case
	(i == 0) : {
	  current_ins.opcode = store_op;
	}
      	(i == 1) : {
	  current_ins.opcode = other_op;	
      	}
      	(i == 2) : {
	  current_ins.opcode = load_op;
      	}
   	esac;    

      instructions[i] = current_ins;
    }
  }

  next {
    step' = step + 1;  

  }
  
  // Bounded model checking limit
  control {
    vobj = unroll(3);
    check;
    print_results;
    vobj.print_cex(step, sic.instructions);
  }
}
	


