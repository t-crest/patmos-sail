module tricore {

	input current_ops, previous_ops: common.instr_pair_t;
	input current_initial_latencies, previous_initial_latencies: common.dual_latencies_t;
	input input_previous_stages: common.dual_stage_t;

	// The instructions
	var current_stages, previous_stages: common.dual_stage_t;
	var current_latencies, previous_latencies: common.dual_integer_t;
	var current_delays, previous_delays: common.dual_integer_t;
	var current_progress, previous_progress: boolean;

	// One pipeline stalled => the other one too
	var current_stalled, previous_stalled: boolean;

	// This computes the next stages and latencies of an instruction pair (previous and current)
	procedure next_stages(progress_prime: boolean, stalled_prime: boolean, stages: common.dual_stage_t, opcodes: common.instr_pair_t, latencies: common.dual_latencies_t, in_latencies: common.dual_integer_t)
	returns (new: common.dual_stage_t, new_latencies: common.dual_integer_t)
	{
		new = stages;
		new_latencies = in_latencies;
		if (progress_prime) {
			case
			  (stages.LS_pipe == pre) : { new.LS_pipe = IF; new_latencies.LS_pipe = latencies.LS_pipe.IF; }
			  (stages.LS_pipe == IF)  : { new.LS_pipe = ID; new_latencies.LS_pipe = latencies.LS_pipe.ID; }
			  (stages.LS_pipe == ID)  : { 
			  	if (opcodes.LS_instr == nop) { new.LS_pipe = post; new_latencies.LS_pipe = 0; }
			  	else { new.LS_pipe = EX; new_latencies.LS_pipe = latencies.LS_pipe.EX; }
			  }
			  (stages.LS_pipe == EX)  : {
			  	if (opcodes.LS_instr == nop) { new.LS_pipe = post; new_latencies.LS_pipe = 0; }
			  	else {new.LS_pipe = WB; new_latencies.LS_pipe = latencies.LS_pipe.WB; }
			  }
			  (stages.LS_pipe == WB || stages.LS_pipe == post)  : { new.LS_pipe = post; new_latencies.LS_pipe = 0; }
			esac
		
			case
			  (stages.I_pipe == pre) : { new.I_pipe = IF; new_latencies.I_pipe = latencies.I_pipe.IF; }
			  (stages.I_pipe == IF)  : { new.I_pipe = ID; new_latencies.I_pipe = latencies.I_pipe.ID; }
			  (stages.I_pipe == ID)  : {
			  	if (opcodes.I_instr == nop) { new.I_pipe = post; new_latencies.I_pipe = 0; }
			  	else { new.I_pipe = EX; new_latencies.I_pipe = latencies.I_pipe.EX; }
			  }
			  (stages.I_pipe == EX)  : { if (opcodes.I_instr == mac_op) { new.I_pipe = EX2; new_latencies.I_pipe = latencies.I_pipe.EX2; }
										else {
											if (opcodes.I_instr == nop) { new.I_pipe = post; new_latencies.I_pipe = 0; }
											else { new.I_pipe = WB; new_latencies.I_pipe = latencies.I_pipe.WB; }
										}
			  }
			  (stages.I_pipe == EX2)  : {
			  	if (opcodes.I_instr == nop) { new.I_pipe = post; new_latencies.I_pipe = 0; }
			  	else { new.I_pipe = WB; new_latencies.I_pipe = latencies.I_pipe.WB; }
			  }
			  (stages.I_pipe == WB || stages.I_pipe == post) : { new.I_pipe = post; new_latencies.I_pipe = 0; }
			esac
		}
		else {
			if (!stalled_prime) {
				if (in_latencies.I_pipe > 0) { new_latencies.I_pipe = in_latencies.I_pipe - 1; }
				if (in_latencies.LS_pipe > 0) { new_latencies.LS_pipe = in_latencies.LS_pipe - 1; }
			}
		}
	}

   // These are the conditions for the previous instructions to check if they can progress
	procedure check_previous_progress(stalled: boolean)
	returns(b_both: boolean) {
		var b: common.dual_boolean_t;
		
		// By default the instructions cannot move to the next stages
		b.I_pipe = false;
		if (previous_latencies.I_pipe <= 1 && !stalled) {
			b.I_pipe = true;
		}

		b.LS_pipe = false;
		if (previous_latencies.LS_pipe <= 1 && !stalled) {
			b.LS_pipe = true;
	  	}
		
		b_both = b.I_pipe && b.LS_pipe;
	}

	// Checking stalls for the previous instructions
	procedure check_previous_stalling(input_delays: common.dual_integer_t)
	returns (b: boolean, output_delays: common.dual_integer_t) {
		// Stalling when one of the current instructions is in IF
		 b = (current_stages.I_pipe == IF && current_latencies.I_pipe > 1) ||
			(current_stages.LS_pipe == IF && current_latencies.LS_pipe > 1) ||
			// Same thing for LS ops in EX stage
			(current_stages.LS_pipe == EX && current_latencies.LS_pipe > 1);

		output_delays = input_delays;
		if (b && previous_stages.I_pipe != post) { output_delays.I_pipe = output_delays.I_pipe + 1; }
		if (b && previous_stages.LS_pipe != post) { output_delays.LS_pipe = output_delays.LS_pipe + 1; }
	}
	
	// These are the conditions for the current instructions to check if they can progress
	procedure check_current_progress(stalled: boolean, pprime_stage: common.dual_stage_t)
	returns(b_both: boolean) {
		// By default the instructions cannot move to the next stages
		var b: common.dual_boolean_t;
		
		// By default the instructions cannot move to the next stages
		b.I_pipe = false;
		// Except if its latency is going to run out or has run out
		// And the pipeline is not stalled due to a cache miss
		if (current_latencies.I_pipe <= 1 && !stalled) {
			case
				// ... and its targeted next stage is not occupied by the previous
				(current_stages.I_pipe == pre) : { if (pprime_stage.I_pipe != IF) { b.I_pipe = true; }}
				(current_stages.I_pipe == IF)  : { if (pprime_stage.I_pipe != ID) { b.I_pipe = true; }}
				(current_stages.I_pipe == ID)  : { if (pprime_stage.I_pipe != EX) { b.I_pipe = true; }}
				(current_stages.I_pipe == EX)  : { if ((current_ops.I_instr != mac_op && pprime_stage.I_pipe != WB) || (current_ops.I_instr == mac_op && pprime_stage.I_pipe != EX2)) { b.I_pipe = true; }}	
				(current_stages.I_pipe == EX2)  : { if (pprime_stage.I_pipe != WB) { b.I_pipe = true; }}		
				// Willing to switch from these stages mean exiting the pipeline ...
				(current_stages.I_pipe == WB || current_stages.I_pipe == post)  : { b.I_pipe = true; }
			esac
		}

		b.LS_pipe = false;
		if (current_latencies.LS_pipe <= 1 && !stalled) {
			case
				// ... and its targeted next stage is not occupied by the previous
				(current_stages.LS_pipe == pre) : { if (pprime_stage.LS_pipe != IF && (pprime_stage.LS_pipe != EX || previous_initial_latencies.LS_pipe.EX == 1)) { b.LS_pipe = true; }}
				(current_stages.LS_pipe == IF)  : { if (pprime_stage.LS_pipe != ID) { b.LS_pipe = true; }}
				(current_stages.LS_pipe == ID)  : { if (pprime_stage.LS_pipe != EX) { b.LS_pipe = true; }}
				(current_stages.LS_pipe == EX)  : { if (pprime_stage.LS_pipe != WB) { b.LS_pipe = true; }}
				(current_stages.LS_pipe == WB || current_stages.LS_pipe == post)  : { b.LS_pipe = true; }
			esac
		}

		b_both = b.I_pipe && b.LS_pipe;
	}

	// Checking stalls for the current instructions
	procedure check_current_stalling(pprime_stages: common.dual_stage_t)
	returns (b: boolean) {
		b = (pprime_stages.LS_pipe == EX && previous_initial_latencies.LS_pipe.EX > 1) ||
			(pprime_stages.LS_pipe == IF && previous_initial_latencies.LS_pipe.IF > 1) ||
			(pprime_stages.I_pipe == IF && previous_initial_latencies.I_pipe.IF > 1);
	}


	init {
		assume(previous_stages == input_previous_stages);

		assume(input_previous_stages.LS_pipe == IF ==> previous_latencies.LS_pipe == previous_initial_latencies.LS_pipe.IF);
		assume(input_previous_stages.LS_pipe == ID ==> previous_latencies.LS_pipe == previous_initial_latencies.LS_pipe.ID);
		assume(input_previous_stages.LS_pipe == EX ==> previous_latencies.LS_pipe == previous_initial_latencies.LS_pipe.EX);
		assume(input_previous_stages.LS_pipe == WB ==> previous_latencies.LS_pipe == previous_initial_latencies.LS_pipe.WB);
		assume(input_previous_stages.LS_pipe == pre ==> previous_latencies.LS_pipe == 1);    

		assume(input_previous_stages.I_pipe == IF ==> previous_latencies.I_pipe == previous_initial_latencies.I_pipe.IF);
		assume(input_previous_stages.I_pipe == ID ==> previous_latencies.I_pipe == previous_initial_latencies.I_pipe.ID);
		assume(input_previous_stages.I_pipe == EX ==> previous_latencies.I_pipe == previous_initial_latencies.I_pipe.EX);
		assume(input_previous_stages.I_pipe == EX2 ==> previous_latencies.I_pipe == previous_initial_latencies.I_pipe.EX2);
		assume(input_previous_stages.I_pipe == WB ==> previous_latencies.I_pipe == previous_initial_latencies.I_pipe.WB);
		assume(input_previous_stages.I_pipe == pre ==> previous_latencies.I_pipe == 1);

		previous_delays.I_pipe = 0; previous_delays.LS_pipe = 0;
		previous_progress = false;
		previous_stalled = false;

		current_stages.I_pipe = pre; current_stages.LS_pipe = pre;
		current_latencies.I_pipe = 0; current_latencies.LS_pipe = 0;
		current_delays.I_pipe = 0; current_delays.LS_pipe = 0;
		current_progress = false;
		current_stalled = false;
	}

	procedure update_delays(delays: common.dual_integer_t, inc_LS: boolean, inc_I: boolean)
	returns (new_delays: common.dual_integer_t) {
		if (inc_LS) { new_delays.LS_pipe = delays.LS_pipe+1; } else { new_delays.LS_pipe = delays.LS_pipe; }
		if (inc_I) { new_delays.I_pipe = delays.I_pipe+1; } else { new_delays.I_pipe = delays.I_pipe; }
	}

	// Updating the state of the instructions
	next {
		call (previous_stalled', previous_delays') = check_previous_stalling(previous_delays);
		call (previous_progress') = check_previous_progress(previous_stalled');
		call (previous_stages', previous_latencies') = next_stages(previous_progress', previous_stalled', previous_stages, previous_ops, previous_initial_latencies, previous_latencies);
		
		call (current_stalled') = check_current_stalling(previous_stages');
		call (current_progress') = check_current_progress(current_stalled', previous_stages');
		call (current_stages', current_latencies') = next_stages(current_progress', current_stalled', current_stages, current_ops, current_initial_latencies, current_latencies);

		call (current_delays') = update_delays(current_delays, !current_progress' && (current_latencies'.LS_pipe == 0 || current_stalled') && current_stages'.LS_pipe != post, !current_progress' && (current_latencies'.I_pipe == 0 || current_stalled') && current_stages'.I_pipe != post);
	}
}
