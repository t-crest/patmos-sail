// Model of a classical in-order pipeline

module inorder {

  input current_op, previous_op: isa.opcode_t;
  input current_latencies, previous_latencies: isa.var_latency_t;
  input current_src, previous_src: isa.src_regs_t;
  input current_dst, previous_dst: isa.reg_t;  

  // Even if this is ugly, this allows to print the value of each
  // variable in the counter-example ...
  var progress: boolean;
  var is_inst_ready : boolean;
  var is_nstage_wbe_free: boolean;  

  // Useless for us as previous is always ready
  // var is_pinst_ready: boolean;
  var is_store_pending: boolean;  
  var is_data_dependant: boolean;

  instance current : instruction(in_opcode: (current_op),
  	   	     		 in_latencies: (current_latencies),
				 execute: (progress));
  instance previous : instruction(in_opcode: (previous_op),
  	   	      		    in_latencies: (previous_latencies),
			            execute: (true));

  var initialized: boolean;

  /* This ensures Lemma IV.1 (progress dependence) */ 
  procedure inst_ready (instruction:isa.inst_t) 
  modifies is_inst_ready, /*is_pinst_ready,*/
  	   is_store_pending, is_data_dependant;
  {
    is_inst_ready = false;

    case
      (instruction.stage == pre) : { //call previous_inst_ready();
  				     is_inst_ready = true;/*is_pinst_ready;*/
    				   }
      (instruction.stage == ID)  : { call data_dependant();
				     is_inst_ready = !is_data_dependant;
				   }
      (instruction.stage == EX)  : { if ((instruction.opcode != load_op) &&
      			    	         (instruction.opcode != store_op)) {
					   call store_pending();
					   is_inst_ready = !is_store_pending;
				     }
    				   }
  /* Lemma IV.2 requires that the latencies of each instruction is decremented */
  /* These cases ensure this for these stages => could be implemented within the pipeline model directly */
  /* Together with the function nstage_wbe_free -> not specific to SIC actually */
      (instruction.stage == MEM || instruction.stage == IF ||
       instruction.stage == ST || instruction.stage == WB) : {
      			       	     is_inst_ready = true;
				   }
    esac
  }

  // We assume the next stage to be free except when it is occupied by the previous instruction
  // and its latency is higher than 1. However, this only works as we have a single previous
  // instruction => here we assume that previous cannot be block by another previous instruction
  procedure nstage_wbe_free ()
  modifies is_nstage_wbe_free;
  {
    is_nstage_wbe_free = true;
    
    case
      (current.instruction.stage == MEM)  : { if (previous.instruction.stage == ST &&
      				    	      	  previous.instruction.var_latencies.st > 1 &&
      				    	      	  current.instruction.opcode == store_op) {
						  is_nstage_wbe_free = false;
					       }
					       if (previous.instruction.stage == WB &&
      				    	      	  previous.instruction.fixed_latencies.wb > 1 &&
      				    	      	  current.instruction.opcode != store_op) {
						  is_nstage_wbe_free = false;
					       }
					    }
      (current.instruction.stage == EX)   : { if (previous.instruction.stage == MEM &&
      				    	      	  previous.instruction.var_latencies.mem > 1) {
						  is_nstage_wbe_free = false;
					      }
					    }
	// We probably do not need to check that current.instruction.opcode is a nop
      (current.instruction.stage == ID)   : { if (previous.instruction.stage == EX &&
      				    	      	  previous.instruction.fixed_latencies.ex > 1) {
						  is_nstage_wbe_free = false;
					      }
					    }
      (current.instruction.stage == IF)   : { if (previous.instruction.stage == ID &&
      				    	      	  previous.instruction.fixed_latencies.id > 1) {
						  is_nstage_wbe_free = false;
					      }
					    }
      (current.instruction.stage == pre)  : { if (previous.instruction.stage == IF &&
      				    	      	  previous.instruction.var_latencies.fetch > 1) {
						  is_nstage_wbe_free = false;
					      }
   					    }
   esac
  }

  // As we only have two instructions, the previous instruction is always ready
  // procedure previous_inst_ready () modifies is_pinst_ready;
  // {
  //   is_pinst_ready = false;
    
  //   if (current.instruction.stage == pre)
  //   {
  //     var in_pre : boolean;
  //     in_pre = false;      

  //     if (previous.instruction.stage != pre)
  //     {
  // 	  in_pre = true;
  //     }
      
  //     if (in_pre) { is_pinst_ready = true; }
  //   }  
  // }

  // Note: in fact this is useless as ST stage models a asynchronous
  // writing which are unlimited in their number ...
  procedure store_pending () modifies is_store_pending;
  {
    is_store_pending = false;

    if (previous.instruction.opcode == store_op &&
        (previous.instruction.stage == IF ||
  	 previous.instruction.stage == ID ||
  	 previous.instruction.stage == EX ||
  	 previous.instruction.stage == MEM ||
	 (previous.instruction.stage == ST && 	 
          previous.instruction.var_latencies.st > 1))) {
  	is_store_pending = true;
    }   
  }


  procedure data_dependant () modifies is_data_dependant;
  {
    is_data_dependant = false;

    if (previous.instruction.opcode == load_op &&
      	(previous.instruction.stage == IF ||
  	 previous.instruction.stage == ID ||
  	 previous.instruction.stage == EX ||
  	 (previous.instruction.stage == MEM &&
	  previous.instruction.var_latencies.mem > 1))) {
       if (current.instruction.src_regs.src1 == previous.instruction.dst_reg ||
  	   current.instruction.src_regs.src2 == previous.instruction.dst_reg) {
  	  is_data_dependant = true;
       }
    }
  }

  init {
    progress = false;
    initialized = false;

    is_data_dependant = false;
  }

  procedure update_progress()
  modifies progress, is_inst_ready, /*is_pinst_ready,*/
  	   is_store_pending, is_data_dependant, is_nstage_wbe_free;
  {
    call inst_ready(current.instruction);
    call nstage_wbe_free();

    progress = is_inst_ready && is_nstage_wbe_free;
  }

  // Updating the state of the instructions
  next  {
    if (!initialized) {
	assume(current.instruction.opcode == current_op);
	assume(previous.instruction.opcode == previous_op);
        assume(current.instruction.var_latencies == current_latencies);
        assume(previous.instruction.var_latencies == previous_latencies);
	assume(current.instruction.src_regs == current_src);
        assume(current.instruction.dst_reg == current_dst);
        assume(previous.instruction.src_regs == previous_src);
        assume(previous.instruction.dst_reg == previous_dst);		
    	initialized' = true;
	// previous instruction can go ahead freely ...
      	next(previous);	
    } else {
	// previous instruction can go ahead freely ...	
	next(previous);
      	call update_progress();	
    	if (progress) { next(current);}
    }
  }
}
