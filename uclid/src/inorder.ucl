// Model of a classical in-order pipeline

module inorder {

  input current_op, previous_op: isa.opcode_t;
  input current_latencies, previous_latencies: isa.var_latency_t;
  input current_src, previous_src: isa.src_regs_t;
  input current_dst, previous_dst: isa.reg_t;  

  // Even if this is ugly, this allows to print the value of each
  // variable in the counter-example ...
  var progress: boolean;
  var is_inst_ready : boolean;
  var is_nstage_wbe_free: boolean;  
  
  var is_ninst_ready: boolean;
  var is_store_pending: boolean;  
  var is_data_dependant: boolean;

  instance current : instruction(in_opcode: (current_op),
  	   	     		 in_latencies: (current_latencies),
				 execute: (progress));
  instance previous : instruction(in_opcode: (previous_op),
  	   	      		    in_latencies: (previous_latencies),
			            execute: (true));

  var initialized: boolean;

  /* This ensures Lemma IV.1 (progress dependence) */ 
  procedure inst_ready (instruction:isa.inst_t) 
  modifies is_inst_ready, is_ninst_ready,
  	   is_store_pending, is_data_dependant;
  {
    is_inst_ready = false;

    case
      (instruction.stage == pre) : { call next_inst_ready();
  				     is_inst_ready = is_ninst_ready;
    				   }
      (instruction.stage == ID)  : { call data_dependant();
				     is_inst_ready = !is_data_dependant;
				   }
      (instruction.stage == EX)  : { if ((instruction.opcode != load_op) &&
      			    	         (instruction.opcode != store_op)) {
					   call store_pending();
					   is_inst_ready = !is_store_pending;
				     }
    				   }
  /* Lemma IV.2 requires that the latencies of each instruction is decremented */
  /* These cases ensure this for these stages => could be implemented within the pipeline model directly */
  /* Together with the function nstage_wbe_free -> not specific to SIC actually */
      (instruction.stage == MEM || instruction.stage == IF ||
       instruction.stage == ST || instruction.stage == WB) : {
      			       	     is_inst_ready = true;
				   }
    esac
  }

  // Should try with an array of previous instructions
  procedure nstage_wbe_free ()
  modifies is_nstage_wbe_free;
  {
    is_nstage_wbe_free = true;
    
    case
      (current.instruction.stage == MEM)  : { if (previous.instruction.stage == ST &&
      				    	      	  previous.instruction.var_latencies.st > 1 &&
      				    	      	  current.instruction.opcode == store_op) {
						  is_nstage_wbe_free = false;
					       }
					       if (previous.instruction.stage == WB &&
      				    	      	  previous.instruction.fixed_latencies.wb > 1 &&
      				    	      	  current.instruction.opcode != store_op) {
						  is_nstage_wbe_free = false;
					       }
					    }
      (current.instruction.stage == EX)   : { if (previous.instruction.stage == MEM &&
      				    	      	  previous.instruction.var_latencies.mem > 1) {
						  is_nstage_wbe_free = false;
					      }
					    }
	// We probably do not need to check that current.instruction.opcode is a nop
      (current.instruction.stage == ID)   : { if (previous.instruction.stage == EX &&
      				    	      	  previous.instruction.fixed_latencies.ex > 1) {
						  is_nstage_wbe_free = false;
					      }
					    }
      (current.instruction.stage == IF)   : { if (previous.instruction.stage == ID &&
      				    	      	  previous.instruction.fixed_latencies.id > 1) {
						  is_nstage_wbe_free = false;
					      }
					    }
      (current.instruction.stage == pre)  : { if (previous.instruction.stage == IF &&
      				    	      	  previous.instruction.var_latencies.fetch > 1) {
						  is_nstage_wbe_free = false;
					      }
   					    }
   esac

   // This is useless for now as long as we only have 2 instructions
   // For more instructions, we need to implement another procedure 
   //call ready(previous.instruction);
   // if (ready_ins)
   // {
   //    call (stage_next_free) = will_be_free(previous.instruction);
   //}
  }

  procedure next_inst_ready () modifies is_ninst_ready;
  {
    is_ninst_ready = false;
    
    if (current.instruction.stage == pre)
    {
      var in_pre : boolean;
      in_pre = false;      

      if (previous.instruction.stage != pre)
      {
  	  in_pre = true;
      }
      
      if (in_pre) { is_ninst_ready = true; }
    }  
  }

  // Note: in fact this is useless as ST stage models a asynchronous
  // writing which are unlimited in their number ...
  procedure store_pending () modifies is_store_pending;
  {
    is_store_pending = false;

    if (previous.instruction.opcode == store_op &&
        (previous.instruction.stage == IF ||
  	 previous.instruction.stage == ID ||
  	 previous.instruction.stage == EX ||
  	 previous.instruction.stage == MEM ||
	 (previous.instruction.stage == ST && 	 
          previous.instruction.var_latencies.st > 1))) {
  	is_store_pending = true;
    }   
  }


  procedure data_dependant () modifies is_data_dependant;
  {
    is_data_dependant = false;

    if (previous.instruction.opcode == load_op &&
      	(previous.instruction.stage == IF ||
  	 previous.instruction.stage == ID ||
  	 previous.instruction.stage == EX ||
  	 (previous.instruction.stage == MEM &&
	  previous.instruction.var_latencies.mem > 1))) {
       if (current.instruction.src_regs.src1 == previous.instruction.dst_reg ||
  	   current.instruction.src_regs.src2 == previous.instruction.dst_reg) {
  	  is_data_dependant = true;
       }
    }
  }

  init {
    progress = false;
    initialized = false;

    is_data_dependant = false;
  }

  procedure update_progress()
  modifies progress, is_inst_ready, is_ninst_ready,
  	   is_store_pending, is_data_dependant, is_nstage_wbe_free;
  {
    call inst_ready(current.instruction);
    call nstage_wbe_free();

    progress = is_inst_ready && is_nstage_wbe_free;
  }

  // Updating the state of the instructions
  next  {
    if (!initialized) {
	assume(current.instruction.opcode == current_op);
	assume(previous.instruction.opcode == previous_op);
//	assume(current.instruction.opcode == nop || current.instruction.);
//	assume(previous.instruction.opcode == previous_op);		
        //assume(current.instruction.var_latencies == current_latencies);
        //assume(previous.instruction.var_latencies == previous_latencies);
	assume(previous.instruction.var_latencies.fetch > 0 &&
	       previous.instruction.var_latencies.fetch <= 10);
	assume(previous.instruction.var_latencies.mem > 0 &&
	       previous.instruction.var_latencies.mem <= 10);
	assume(previous.instruction.var_latencies.st > 0 &&
	       previous.instruction.var_latencies.st <= 10);
	assume(current.instruction.var_latencies.fetch > 0 &&
	       current.instruction.var_latencies.fetch <= 10);
	assume(current.instruction.var_latencies.mem > 0 &&
	       current.instruction.var_latencies.mem <= 10);
	assume(current.instruction.var_latencies.st > 0 &&
	       current.instruction.var_latencies.st <= 10);	       	       	       
        assume(current.instruction.src_regs == current_src);
        assume(current.instruction.dst_reg == current_dst);
        assume(previous.instruction.src_regs == previous_src);
        assume(previous.instruction.dst_reg == previous_dst);		
    	initialized' = true;
	// previous instruction can go ahead freely ...
      	next(previous);	
    } else {
      	call update_progress();
	next(previous); 	
    	if (progress) { next(current);}
    }
  }
}
