// Model of Patmos

// Patmos: => no data dependencies enforced using assume, multiply per two the number of
// instructions to implement the dual-issue and assume that only, control flow operations
// only on pipeline 0 (assume again), load and store only from pipeline 0 (assume again), 

module sic {

  input current_op, previous_op: isa.opcode_t;
  input current_latencies, previous_latencies: isa.var_latency_t;
  input current_src, previous_src: isa.src_regs_t;
  input current_dst, previous_dst: isa.reg_t;  

  // Even if this is ugly, this allows to print the value of each
  // variable in the counter-example ...
  var progress: boolean;
  var is_inst_ready : boolean;
  var is_nstage_wbe_free: boolean;
  
  // Useless for us as previous is always ready
  // var is_pinst_ready: boolean;

  instance current : instruction(in_opcode: (current_op),
  	   	     		 in_latencies: (current_latencies),
				 execute: (progress));
  instance previous : instruction(in_opcode: (previous_op),
  	   	      		    in_latencies: (previous_latencies),
			            execute: (true));

  var initialized: boolean;

  /* This ensures Lemma IV.1 (progress dependence) */ 
  procedure inst_ready (instruction:isa.inst_t) 
  modifies is_inst_ready, is_branch_pending, /*is_pinst_ready,*/
  	   is_store_pending, is_mem_pending, is_data_dependant;
  {
    is_inst_ready = false;

    case
      (instruction.stage == pre) : { /* call previous_inst_ready(); */
  				     call mem_pending(); 
  				     is_inst_ready  = !is_branch_pending &&
				     	     	      /*is_ninst_ready &&*/
						      !is_mem_pending;
    				   }
      (instruction.stage == ID)  : { call data_dependant();
				     is_inst_ready = !is_data_dependant;
				   }
      (instruction.stage == EX)  : { if ((instruction.opcode != load_op) &&
      			    	         (instruction.opcode != store_op)) {
					   call store_pending();
					   is_inst_ready = !is_store_pending;
				     }
    				   }
  /* Lemma IV.2 requires that the latencies of each instruction is decremented */
  /* These cases ensure this for these stages => could be implemented within the pipeline model directly */
  /* Together with the function nstage_wbe_free -> not specific to SIC actually */
      (instruction.stage == MEM || instruction.stage == IF ||
       instruction.stage == ST || instruction.stage == WB) : {
      			       	     is_inst_ready = true;
				   }
    esac
  }

  // As we only have two instructions, the previous instruction is always ready
  // procedure previous_inst_ready () modifies is_pinst_ready;
  // {
  //   is_pinst_ready = false;
    
  //   if (current.instruction.stage == pre)
  //   {
  //     var in_pre : boolean;
  //     in_pre = false;      

  //     if (previous.instruction.stage != pre)
  //     {
  // 	  in_pre = true;
  //     }
      
  //     if (in_pre) { is_pinst_ready = true; }
  //   }  
  // }


  init {
    progress = false;
    initialized = false;
  }

  procedure update_progress()
  modifies progress, is_inst_ready, is_mem_pending, is_ninst_ready,
  	   is_store_pending, is_branch_pending, is_data_dependant, is_nstage_wbe_free;
  {
    call inst_ready(current.instruction);
    call nstage_wbe_free();

    progress = is_inst_ready && is_nstage_wbe_free;
  }

  // Updating the state of the instructions
  next  {
    if (!initialized) {
	assume(current.instruction.opcode == current_op);
	assume(previous.instruction.opcode == previous_op);
        assume(current.instruction.var_latencies == current_latencies);
        assume(previous.instruction.var_latencies == previous_latencies);
        assume(current.instruction.src_regs == current_src);
        assume(current.instruction.dst_reg == current_dst);
        assume(previous.instruction.src_regs == previous_src);
        assume(previous.instruction.dst_reg == previous_dst);		
    	initialized' = true;
	// previous instruction can go ahead freely ...
      	next(previous);	
    } else {
	// previous instruction can go ahead freely ...	
	next(previous);
      	call update_progress();	
    	if (progress) { next(current);}
    }
  }
}
