module isa {
  // Pipeline stages
  type stage_t = enum { pre, IF, ID, EX, MEM, ST, WB, post };

//  type stage_k1_t = enum { pre, PF, ID, RR, E1, E2, E3, E4, post };

  // Opcode 
  type opcode_t = enum { nop, load_op, store_op, branch_op, other_op };

  //type opcode_k1_t = enum { alu_op, lsu_op, bcu_id_op, bcu_rr_op, mau_op };

  // Registers. 5 bits to allow 32 registers
  type reg_t = bv5;

  // Source registers
  type src_regs_t = record { src1: reg_t, src2: reg_t };

  // Variable latencies for each instruction
  type var_latency_t = record { fetch: integer, mem: integer, st: integer };

  // Latencies information for each instruction
  type fixed_latency_t = record { id: integer, ex: integer, wb: integer };

  type latencies_t = record { fetch: integer, id: integer, ex: integer, mem: integer, wb: integer};

  type latencies_k1_t = record { fetch: integer, mem: integer};

  // Instruction 
  type inst_regs_t = record { opcode: opcode_t,
			 var_latencies: var_latency_t,
			 fixed_latencies: fixed_latency_t,
			 delay: integer,
			 src_regs: src_regs_t,
			 dst_reg: reg_t,			 
			 stage: stage_t };

  // Instruction 
  type inst_t = record { opcode: opcode_t,
			 var_latencies: var_latency_t,
			 fixed_latencies: fixed_latency_t,
			 delay: integer,
			 new_stage: boolean,			 
			 stage: stage_t };

  // Instruction 
  type inst_pret_t = record { opcode: opcode_t,
			 var_latencies: var_latency_t,
			 fixed_latencies: fixed_latency_t,
			 tid: bv2,
			 delay: integer,
			 new_stage: boolean,			 
			 stage: stage_t };

}
