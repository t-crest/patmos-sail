module isa {
  // Pipeline stages
  type stage_t = enum { pre, IF, ID, EX, MEM, ST, WB, post };

  // Opcode 
  type opcode_t = enum { nop, load_op, store_op, branch_op, other_op };

  // Registers. 5 bits to allow 32 registers
  type reg_t = bv5;

  // Source registers
  type src_regs_t = record { src1: reg_t, src2: reg_t };

  // We prefer to directly modify the latencies, instead of having a single latency
  // variable which would be initialized with the latency of each stage.
  // This allows to more easily see how the system evolves and put sanety checks
  // This also allows to more easily implement nstage_wbe_free
  // However, a single latency variable would simplify the instruction module
  // as the first things to do would be to decrement the current value of the latency
  // => This is how it is done in SIC
  
  // Variable latencies for each instruction
  type var_latency_t = record { fetch: integer, mem: integer, st: integer };

  // Latencies information for each instruction
  type fixed_latency_t = record { id: integer, ex: integer, wb: integer };

  // Instruction 
  type inst_regs_t = record { opcode: opcode_t,
			 var_latencies: var_latency_t,
			 fixed_latencies: fixed_latency_t,
			 delay: integer,
			 src_regs: src_regs_t,
			 dst_reg: reg_t,			 
			 stage: stage_t };

  // Instruction 
  type inst_t = record { opcode: opcode_t,
			 var_latencies: var_latency_t,
			 fixed_latencies: fixed_latency_t,
			 delay: integer,
			 new_stage: boolean,			 
			 stage: stage_t };

  // Instruction 
  type inst_pret_t = record { opcode: opcode_t,
			 var_latencies: var_latency_t,
			 fixed_latencies: fixed_latency_t,
			 tid: bv2,
			 delay: integer,
			 stage: stage_t };
}
