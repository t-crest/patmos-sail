// NOTE: it would have been great to put generic rules to any pipeline in this
// module (procedure nstage_wbe_free mainly). However this requires to put the
// previous instruction in the flow of program as input and to distinguish using a
// boolean input, the special case of the 1st instruction of a flow (no previous
// instruction) from the others ...

module instruction {

  // Latencies and opcode are input values from another and thus readonly data.
  // Even if in_opcode could be used directly instead of instruction.op_code
  // This would goes against a modular description of the model
  input in_latencies: isa.var_latency_t;
  // The opcode which is set 
  input in_opcode: isa.opcode_t;
  // Can we make some progress
  input execute: boolean;

  // The instruction
  var instr: isa.inst_t;
  
  procedure latency_IF() modifies instr; {
    instr.var_latencies.fetch = instr.var_latencies.fetch - 1;
  }

  procedure latency_MEM() modifies instr; {
    instr.var_latencies.mem = instr.var_latencies.mem - 1;
  }

  procedure latency_ST() modifies instr; {
    instr.var_latencies.st = instr.var_latencies.st - 1;
  }

  procedure latency_ID() modifies instr; {
    instr.fixed_latencies.id = instr.fixed_latencies.id - 1;
  }

  procedure latency_EX() modifies instr; {
    instr.fixed_latencies.ex = instr.fixed_latencies.ex - 1;
  }

  procedure latency_WB() modifies instr; {
    instr.fixed_latencies.wb = instr.fixed_latencies.wb - 1;
  }

  procedure update_stage() modifies instr; {
       case
	  (instr.stage == pre) : { instr.stage = IF; }
	  (instr.stage == IF)  : { if (instr.var_latencies.fetch == 0)
	  		     	       	   { instr.stage = ID; }
	  	    	     		 else { call latency_IF(); }
				       }
	  (instr.stage == ID)  : { if (instr.fixed_latencies.id == 0) {
	  		     	     if (instr.opcode != nop && instr.opcode != branch_op)
				       { instr.stage = EX; }
	  	    	     	     else { instr.stage = post; }
			 	   } else { call latency_ID(); }
				 }
	  (instr.stage == EX)  : { if (instr.fixed_latencies.ex == 0) {
	  		     	       	    instr.stage = MEM;
					 } else { call latency_EX(); }
				       }
	  (instr.stage == MEM) : { if (instr.var_latencies.mem == 0) {
	  	    	     	       	   if (instr.opcode == store_op)
					   { instr.stage = ST; }
	  		     		   else { instr.stage = WB; }
			     		 } else { call latency_MEM(); }
	  		   	       }
	  (instr.stage == ST)  : { if (instr.var_latencies.st == 0)
	  		     	       	   { instr.stage = post; }
			     		 else { call latency_ST(); }
			   	       }
	  (instr.stage == WB ) : { if (instr.fixed_latencies.wb == 0) {
	  		     	       	    instr.stage = post;
					  } else  { call latency_WB(); }
				       }
      esac
  }


  init {
    instr.stage = pre;
    instr.fixed_latencies.id = 1;
    instr.fixed_latencies.ex = 1;
    instr.fixed_latencies.wb = 1;
  }

  next {
    if (execute) {
      call update_stage();
    } 
  }
}
	


