// Model of SIC (strictly in-order pipeline)

// In an in-order pipeline, instruction i can be blocked by a
// subsequent instruction k (k>i) while k is in fetch stage performing
// a memory access. In SIC, this is avoided as instruction k will not be
// authorized to get in in the pipeline until instruction i leaves stage MEM.
// The property is thus: if i is in MEM, then k cannot be in fetch
// However, this property is defined by using stages and not latencies
// (and variation in latencies)

// Progression of an instruction in SIC only depends on the previous instruction,
// not on subsequent instructions. Another way of specifying the property would be:
// whenever an instruction i reaches stage MEM and an instruction k reaches stage IF,
// then the i is blocked by a subsequent instruction => store the amount of time i is
// blocked.  ==> previous is current and current is subsequent

// Storing the amount of time allows to specify the property using LTL
//(when BMC bound is reached) => check if blocking delay is null. An
// invariant could be used as well ...

// Specification of the property: other ways
// Use two instances of the same pipeline, but force on to always take the worst-case behavior
// while the other one take any value lower. Then, compare the finish time of each instruction
// => invariant is enough (in the current version using stages, an invariant should be enough
// as well)

// Paper SIC: Lemma IV.1 would make a nice invariant to check on SIC
// It is unclear what should we do with the previous equation

module sic {

  input current_op, previous_op: isa.opcode_t;
  input current_latencies, previous_latencies: isa.var_latency_t;
  input current_src, previous_src: isa.src_regs_t;
  input current_dst, previous_dst: isa.reg_t;  

  // Even if this is ugly, this allows to print the value of each
  // variable in the counter-example ...
  var progress: boolean;
  var is_inst_ready : boolean;
  var is_nstage_wbe_free: boolean;  
  
  var is_branch_pending : boolean;
  // Useless for us as previous is always ready
  //var is_pinst_ready: boolean;
  var is_mem_pending: boolean;
  var is_store_pending: boolean;
  var is_data_dependant: boolean;

  instance previous : instruction(in_opcode: (previous_op),
  	   	      		  in_latencies: (previous_latencies),
			          execute: (true));
  instance current : instruction(in_opcode: (current_op),
  	   	     		 in_latencies: (current_latencies),
				 execute: (progress));				    

  var initialized: boolean;

  /* This ensures Lemma IV.1 (progress dependence) */ 
  procedure inst_ready (instruction:isa.inst_t) 
  modifies is_inst_ready, is_branch_pending, /*is_pinst_ready,*/
  	   is_store_pending, is_mem_pending, is_data_dependant;
  {
    is_inst_ready = false;

    case
      (instruction.stage == pre) : { call branch_pending();
  			    	     //call previous_inst_ready();
  				     call mem_pending(); 
  				     is_inst_ready  = !is_branch_pending &&
				     	     	      /*is_pinst_ready &&*/
						      !is_mem_pending;
    				   }
      (instruction.stage == ID)  : { call data_dependant();
				     is_inst_ready = !is_data_dependant;
				   }
      (instruction.stage == EX)  : { if ((instruction.opcode != load_op) &&
      			    	         (instruction.opcode != store_op)) {
					   call store_pending();
					   is_inst_ready = !is_store_pending;
				     }
    				   }
  /* Lemma IV.2 requires that the latencies of each instruction is decremented */
  /* These cases ensure this for these stages => could be implemented within the pipeline model directly */
  /* Together with the function nstage_wbe_free -> not specific to SIC actually */
  /* See comment within the instruction module for a discussion */
      (instruction.stage == MEM || instruction.stage == IF ||
       instruction.stage == ST || instruction.stage == WB) : {
      			       	     is_inst_ready = true;
				   }
    esac
  }

  // This version of willbefree from the SIC paper is much simpler
  // We assume the next stage to be free except when it is occupied by the previous instruction
  // and its latency is higher than 1. However, this only works as we have a single previous
  // instruction => here we assume that previous cannot be block by another previous instruction
  procedure nstage_wbe_free ()
  modifies is_nstage_wbe_free;
  {
    is_nstage_wbe_free = true;
    
    case
      (current.instruction.stage == MEM)  : { if (previous.instruction.stage == ST &&
      				    	      	  previous.instruction.var_latencies.st > 1 &&
      				    	      	  current.instruction.opcode == store_op) {
						  is_nstage_wbe_free = false;
					       }
					       if (previous.instruction.stage == WB &&
      				    	      	  previous.instruction.fixed_latencies.wb > 1 &&
      				    	      	  current.instruction.opcode != store_op) {
						  is_nstage_wbe_free = false;
					       }
					    }
      (current.instruction.stage == EX)   : { if (previous.instruction.stage == MEM &&
      				    	      	  previous.instruction.var_latencies.mem > 1) {
						  is_nstage_wbe_free = false;
					      }
					    }
      (current.instruction.stage == ID)   : { if (previous.instruction.stage == EX &&
      				    	      	  previous.instruction.fixed_latencies.ex > 1) {
						  is_nstage_wbe_free = false;
					      }
					    }
      (current.instruction.stage == IF)   : { if (previous.instruction.stage == ID &&
      				    	      	  previous.instruction.fixed_latencies.id > 1) {
						  is_nstage_wbe_free = false;
					      }
					    }
      (current.instruction.stage == pre)  : { if (previous.instruction.stage == IF &&
      				    	      	  previous.instruction.var_latencies.fetch > 1) {
						  is_nstage_wbe_free = false;
					      }
   					    }
   esac
  }

  // As we only have two instructions, the previous instruction is always ready
  // procedure previous_inst_ready () modifies is_pinst_ready;
  // {
  //   is_ninst_ready = false;
    
  //   if (current.instruction.stage == pre)
  //   {
  //     var in_pre : boolean;
  //     in_pre = false;      

  //     if (previous.instruction.stage != pre)
  //     {
  // 	  in_pre = true;
  //     }
      
  //     if (in_pre) { is_pinst_ready = true; }
  //   }  
  // }

  procedure branch_pending () modifies is_branch_pending;
  {
    is_branch_pending = false;

    if (previous.instruction.opcode == branch_op &&
        (previous.instruction.stage == IF ||
  	 previous.instruction.stage == ID ||
  	 (previous.instruction.stage == EX &&
	  previous.instruction.fixed_latencies.ex > 1))) {
  	is_branch_pending = true;
    }
  }

  procedure mem_pending () modifies is_mem_pending, is_store_pending;
  {
    var load : boolean;

    is_store_pending = false;
    is_mem_pending = false;

    load = false;
    
    if (previous.instruction.opcode == load_op &&
      	(previous.instruction.stage == IF ||
  	 previous.instruction.stage == ID ||
  	 previous.instruction.stage == EX || 
  	 (previous.instruction.stage == MEM &&
	  previous.instruction.var_latencies.mem > 1)))  {
  	load = true;
    }

    call store_pending();

    is_mem_pending = is_store_pending || load;
  }

  // Note: in fact this is useless as ST stage models a asynchronous
  // writing which are unlimited in their number ...
  procedure store_pending () modifies is_store_pending;
  {
    is_store_pending = false;

    if (previous.instruction.opcode == store_op &&
        (previous.instruction.stage == IF ||
  	 previous.instruction.stage == ID ||
  	 previous.instruction.stage == EX ||
  	 previous.instruction.stage == MEM ||
	 (previous.instruction.stage == ST && 	 
          previous.instruction.var_latencies.st > 1))) {
  	is_store_pending = true;
    }   
  }

  // Seems that this rule is useless in fact, as mem_pending ensures this!
  // Conclusion: SIC is a PRET architecture where the slot between instructions
  // is computed dynamically ... However SIC does not allow other thread to go in
  // => Mixing PRET and SIC should be great!
  procedure data_dependant () modifies is_data_dependant;
  {
    is_data_dependant = false;

    if (previous.instruction.opcode == load_op &&
      	(previous.instruction.stage == IF ||
  	 previous.instruction.stage == ID ||
  	 previous.instruction.stage == EX ||
  	 (previous.instruction.stage == MEM &&
	  previous.instruction.var_latencies.mem > 1))) {
       if (current.instruction.src_regs.src1 == previous.instruction.dst_reg ||
  	   current.instruction.src_regs.src2 == previous.instruction.dst_reg) {
  	  is_data_dependant = true;
       }
    }
  }

  init {
    progress = false;
    initialized = false;
  }

  procedure update_progress()
  modifies progress, is_inst_ready, is_mem_pending, /*is_pinst_ready,*/
  	   is_store_pending, is_branch_pending,
	   is_data_dependant, is_nstage_wbe_free;
  {
    call inst_ready(current.instruction);
    call nstage_wbe_free();

    progress = is_inst_ready && is_nstage_wbe_free;
  }

  // Updating the state of the instructions
  next  {
    if (!initialized) {
	assume(current.instruction.opcode == current_op);
	assume(previous.instruction.opcode == previous_op);
        assume(current.instruction.var_latencies == current_latencies);
        assume(previous.instruction.var_latencies == previous_latencies);
        assume(current.instruction.src_regs == current_src);
        assume(current.instruction.dst_reg == current_dst);
        assume(previous.instruction.src_regs == previous_src);
        assume(previous.instruction.dst_reg == previous_dst);		
    	initialized' = true;
	// previous instruction can go ahead freely ...
      	next(previous);	
    } else {
	// previous instruction can go ahead freely ...	
	next(previous);
      	call update_progress();	
    	if (progress) { next(current);}
    }
  }
}

